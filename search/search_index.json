{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PUMA: Plotting UMami Api","text":"<p>The Python package <code>puma</code> provides a plotting API for commonly used plots in flavour tagging.</p> ROC curves Histogram plots Variable vs efficiency"},{"location":"#installation","title":"Installation","text":"<p><code>puma</code> can be installed from PyPI or using the latest code from this repository.</p>"},{"location":"#install-latest-release-from-pypi","title":"Install latest release from PyPI","text":"<pre><code>pip install puma-hep\n</code></pre> <p>The installation from PyPI only allows to install tagged releases, meaning you can not install the latest code from this repo using the above command. If you just want to use a stable release of <code>puma</code>, this is the way to go.</p>"},{"location":"#install-latest-version-from-github","title":"Install latest version from GitHub","text":"<pre><code>pip install https://github.com/umami-hep/puma/archive/main.tar.gz\n</code></pre> <p>This will install the latest version of <code>puma</code>, i.e. the current version from the <code>main</code> branch (no matter if it is a release/tagged commit). If you plan on contributing to <code>puma</code> and/or want the latest version possible, this is what you want.</p>"},{"location":"#docker-images","title":"Docker images","text":"<p>The Docker images are built on GitHub and contain the latest version from the <code>main</code> branch.</p> <p>The container registry with all available tags can be found here.</p> <p>The <code>puma:latest</code> image is based on <code>python:3.11.10-bullseye</code> and is meant for users who want to use the latest version of <code>puma</code>. For each release, there is a corresponding tagged image. You can start an interactive shell in a container with your current working directory mounted into the container by using one of the commands provided below.</p> <p>On a machine with Docker installed:</p> <pre><code>docker run -it --rm -v $PWD:/puma_container -w /puma_container gitlab-registry.cern.ch/atlas-flavor-tagging-tools/training-images/puma-images/puma:latest bash\n</code></pre> <p>On a machine/cluster with singularity installed:</p> <pre><code>singularity shell -B $PWD docker://gitlab-registry.cern.ch/atlas-flavor-tagging-tools/training-images/puma-images/puma:latest\n</code></pre> <p>The images are automatically updated via GitHub and pushed to this repository registry.</p>"},{"location":"api/fraction_scan/","title":"Fraction Scan","text":""},{"location":"api/fraction_scan/#puma.fraction_scan.get_fx_values","title":"<code>puma.fraction_scan.get_fx_values</code>","text":"Source code in <code>puma/fraction_scan.py</code> <pre><code>def get_fx_values(resolution=100):\n    return np.concatenate((\n        np.logspace(-3, -1, resolution // 2),\n        np.linspace(0.1, 1.0, resolution // 2),\n    ))\n</code></pre>"},{"location":"api/fraction_scan/#puma.fraction_scan.get_efficiency","title":"<code>puma.fraction_scan.get_efficiency</code>","text":"Source code in <code>puma/fraction_scan.py</code> <pre><code>def get_efficiency(scores, fx):\n    return np.sum(scores &gt; fx) / len(scores)\n</code></pre>"},{"location":"api/fraction_scan/#puma.fraction_scan.get_optimal_fc","title":"<code>puma.fraction_scan.get_optimal_fc</code>","text":"<p>After calculating an fc scan, find the optimal value of fc.</p> <p>Parameters:</p> Name Type Description Default <code>fc_scan</code> <code>numpy.ndarray</code> <p>2D array of efficiency (or rejection) scores for each value of fc.</p> required <code>fc_space</code> <code>numpy.ndarray</code> <p>1D array of fc values.</p> required <code>rej</code> <code>bool</code> <p>If True, find the maximum rejection values else find the minimum efficiency values, by default False.</p> <code>False</code> Source code in <code>puma/fraction_scan.py</code> <pre><code>def get_optimal_fc(fc_scan: np.ndarray, fc_space: np.ndarray, rej=False):\n    \"\"\"After calculating an fc scan, find the\n    optimal value of fc.\n\n\n    Parameters\n    ----------\n    fc_scan : np.ndarray\n        2D array of efficiency (or rejection) scores\n        for each value of fc.\n    fc_space : np.ndarray\n        1D array of fc values.\n    rej : bool, optional\n        If True, find the maximum rejection values else\n        find the minimum efficiency values, by default False.\n    \"\"\"\n    # normalise x- and y-axes\n    xs, ys = fc_scan[:, 0], fc_scan[:, 1]\n    xs = xs / max(xs)\n    ys = ys / max(ys)\n\n    # if rej=True get maximum distance to origin\n    opt_idx = np.argmax(xs**2 + ys**2) if rej else np.argmin(xs**2 + ys**2)\n\n    return opt_idx, fc_space[opt_idx]\n</code></pre>"},{"location":"api/histogram/","title":"Histogram","text":""},{"location":"api/histogram/#puma.histogram.Histogram","title":"<code>puma.histogram.Histogram</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>Histogram class storing info about histogram and allows to calculate ratio w.r.t other histograms.</p> <p>Initialise properties of histogram curve object.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>numpy.ndarray</code> <p>Input data for the histogram. If bin_edges is specified (not None) then this array is treated as the bin heights.</p> required <code>weights</code> <code>numpy.ndarray</code> <p>Weights for the input data. Has to be an array of same length as the input data with a weight for each entry. If not specified, weight 1 will be given to each entry. The uncertainties are calculated as the square root of the squared weights (for each bin separately). By default None.</p> <code>None</code> <code>bin_edges</code> <code>numpy.ndarray</code> <p>If specified, the histogram is considered \"filled\": the array given to values is treated as if it was the bin heights corresponding to these bin_edges and the \"weights\" input is ignored. By default None.</p> <code>None</code> <code>sum_squared_weights</code> <code>numpy.ndarray</code> <p>Only considered if the histogram is considered filled (i.e bin_edges is specified). It is the sum_squared_weights per bin. By default None.</p> <code>None</code> <code>ratio_group</code> <code>str</code> <p>Name of the ratio group this histogram is compared with. The ratio group allows you to compare different groups of histograms within one plot. By default None</p> <code>None</code> <code>flavour</code> <code>str | ftag.Label</code> <p>If set, the correct colour and a label prefix will be extracted from <code>puma.utils.global_config</code> set for this histogram. Allowed values are e.g. \"bjets\", \"cjets\", \"ujets\", \"bbjets\", ... By default None</p> <code>None</code> <code>add_flavour_label</code> <code>bool</code> <p>Set to False to suppress the automatic addition of the flavour label prefix in the label of the curve (i.e. \"b-jets\" in the case of b-jets). This is ignored if <code>flavour</code> is not set. By default True</p> <code>True</code> <code>histtype</code> <code>str</code> <p><code>histtype</code> parameter which is handed to matplotlib.hist() when plotting the histograms. Supported values are \"bar\", \"barstacked\", \"step\", \"stepfilled\". By default \"step\"</p> <code>'step'</code> <code>is_data</code> <code>bool</code> <p>Decide, if the plot object will be treated as data (black dots, no stacking), by default False</p> <code>False</code> <code>**kwargs</code> <code>puma.histogram.Histogram(kwargs)</code> <p>Keyword arguments passed to <code>puma.plot_base.PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input data is not of type np.ndarray or list</p> <code>ValueError</code> <p>If weights are specified but have different length as the input values</p> Source code in <code>puma/histogram.py</code> <pre><code>def __init__(\n    self,\n    values: np.ndarray,\n    weights: np.ndarray = None,\n    bin_edges: np.ndarray = None,\n    sum_squared_weights: np.ndarray = None,\n    ratio_group: str | None = None,\n    flavour: str | Label = None,\n    add_flavour_label: bool = True,\n    histtype: str = \"step\",\n    is_data: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialise properties of histogram curve object.\n\n    Parameters\n    ----------\n    values : np.ndarray\n        Input data for the histogram. If bin_edges is specified (not None)\n        then this array is treated as the bin heights.\n    weights : np.ndarray, optional\n        Weights for the input data. Has to be an array of same length as the input\n        data with a weight for each entry. If not specified, weight 1 will be given\n        to each entry. The uncertainties are calculated as the square root of the\n        squared weights (for each bin separately). By default None.\n    bin_edges : np.ndarray, optional\n        If specified, the histogram is considered \"filled\": the array given to\n        values is treated as if it was the bin heights corresponding to these\n        bin_edges and the \"weights\" input is ignored. By default None.\n    sum_squared_weights : np.ndarray, optional\n        Only considered if the histogram is considered filled (i.e bin_edges\n        is specified). It is the sum_squared_weights per bin.\n        By default None.\n    ratio_group : str, optional\n        Name of the ratio group this histogram is compared with. The ratio group\n        allows you to compare different groups of histograms within one plot.\n        By default None\n    flavour: str | Label, optional\n        If set, the correct colour and a label prefix will be extracted from\n        `puma.utils.global_config` set for this histogram.\n        Allowed values are e.g. \"bjets\", \"cjets\", \"ujets\", \"bbjets\", ...\n        By default None\n    add_flavour_label : bool, optional\n        Set to False to suppress the automatic addition of the flavour label prefix\n        in the label of the curve (i.e. \"$b$-jets\" in the case of b-jets).\n        This is ignored if `flavour` is not set. By default True\n    histtype: str, optional\n        `histtype` parameter which is handed to matplotlib.hist() when plotting the\n        histograms. Supported values are \"bar\", \"barstacked\", \"step\", \"stepfilled\".\n        By default \"step\"\n    is_data : bool, optional\n        Decide, if the plot object will be treated as data (black dots,\n        no stacking), by default False\n    **kwargs : kwargs\n        Keyword arguments passed to `puma.plot_base.PlotLineObject`\n\n    Raises\n    ------\n    ValueError\n        If input data is not of type np.ndarray or list\n    ValueError\n        If weights are specified but have different length as the input values\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if isinstance(values, (np.ndarray, list, pd.core.series.Series)):\n        values = np.array(values)\n        if len(values) == 0:\n            logger.warning(\"Histogram is empty.\")\n    else:\n        raise TypeError(\n            \"Invalid type of histogram input data. Allowed values are \"\n            \"numpy.ndarray, list, pandas.core.series.Series\"\n        )\n    if weights is not None and len(values) != len(weights):\n        raise ValueError(\"`values` and `weights` are not of same length.\")\n\n    self.values = values\n    self.bin_edges = bin_edges  # Important to have this defined for any histogram\n    self.sum_squared_weights = sum_squared_weights\n\n    if bin_edges is None and sum_squared_weights is not None:\n        logger.warning(\n            \"\"\"The Histogram has no bin edges defined and is thus\n                          not considered filled. Parameter `sum_squared_weights`\n                          is ignored. \"\"\"\n        )\n\n    # This attribute allows to know how to handle the histogram later during\n    # plotting\n    self.filled = bin_edges is not None\n\n    self.weights = weights\n    self.ratio_group = ratio_group\n    self.flavour = Flavours[flavour] if isinstance(flavour, str) else flavour\n    self.add_flavour_label = add_flavour_label\n    self.histtype = histtype\n    self.is_data = is_data\n\n    # Set histogram attributes to None. They will be defined when the histograms\n    # are plotted\n    self.hist = None\n    self.unc = None\n    self.band = None\n    self.key = None\n\n    label = kwargs[\"label\"] if \"label\" in kwargs and kwargs[\"label\"] is not None else \"\"\n    # If flavour was specified, extract configuration from global config\n    if self.flavour is not None:\n        if self.flavour in Flavours:\n            # Use globally defined flavour colour if not specified\n            if self.colour is None:\n                self.colour = self.flavour.colour\n                logger.debug(\"Histogram colour was set to %s\", self.colour)\n            # Add globally defined flavour label if not suppressed\n            if self.add_flavour_label:\n                global_flavour_label = self.flavour.label\n                self.label = f\"{global_flavour_label} {label}\"\n            else:\n                self.label = label\n            logger.debug(\"Histogram label was set to %s\", {self.label})\n        else:\n            logger.warning(\"The flavour '%s' was not found in the global config.\", self.flavour)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.Histogram.divide","title":"<code>divide</code>","text":"<p>Calculate ratio between two class objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>histogram class</code> <p>Second histogram object to calculate ratio with</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Ratio</p> <code>numpy.ndarray</code> <p>Ratio error</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If binning is not identical between 2 objects</p> <code>ValueError</code> <p>If hist attribute is not set for one of the two histograms</p> <code>ValueError</code> <p>If bin_edges attribute is not set for one of the two histograms</p> Source code in <code>puma/histogram.py</code> <pre><code>def divide(self, other):\n    \"\"\"Calculate ratio between two class objects.\n\n    Parameters\n    ----------\n    other : histogram class\n        Second histogram object to calculate ratio with\n\n    Returns\n    -------\n    np.ndarray\n        Ratio\n    np.ndarray\n        Ratio error\n\n    Raises\n    ------\n    ValueError\n        If binning is not identical between 2 objects\n    ValueError\n        If hist attribute is not set for one of the two histograms\n    ValueError\n        If bin_edges attribute is not set for one of the two histograms\n    \"\"\"\n    if (\n        self.bin_edges is None\n        or other.bin_edges is None\n        or self.hist is None\n        or other.hist is None\n    ):\n        raise ValueError(\n            \"Can't divide histograms since bin edges and counts are not available \"\n            \"for both histogram. Bins are filled when they are plotted.\"\n        )\n\n    if not np.all(self.bin_edges == other.bin_edges):\n        raise ValueError(\"The binning of the two given objects do not match.\")\n\n    # Bins where the reference histogram is empty/zero, are given a ratio of np.inf\n    # which means that the ratio plot will not have any entry in these bins.\n    ratio, ratio_unc = hist_ratio(\n        numerator=self.hist,\n        denominator=other.hist,\n        numerator_unc=self.unc,\n        step=False,\n    )\n    # To use the matplotlib.step() function later on, the first bin is duplicated\n    ratio = np.append(np.array([ratio[0]]), ratio)\n    ratio_unc = np.append(np.array([ratio_unc[0]]), ratio_unc)\n\n    return (ratio, ratio_unc)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.Histogram.divide_data_mc","title":"<code>divide_data_mc</code>","text":"<p>Similar as divide, but the second item doesn't need to be a histogram object.</p> <p>Parameters:</p> Name Type Description Default <code>ref_hist</code> <code>numpy.ndarray</code> <p>Hist weights of the reference.</p> required <code>ref_unc</code> <code>numpy.ndarray</code> <p>Uncertainties of the reference</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of the ratios and ratio uncertaintes for the bins</p> Source code in <code>puma/histogram.py</code> <pre><code>def divide_data_mc(\n    self,\n    ref_hist: np.ndarray,\n) -&gt; tuple:\n    \"\"\"\n    Similar as divide, but the second item doesn't need to be a histogram object.\n\n    Parameters\n    ----------\n    ref_hist : np.ndarray\n        Hist weights of the reference.\n    ref_unc : np.ndarray\n        Uncertainties of the reference\n\n    Returns\n    -------\n    tuple\n        Tuple of the ratios and ratio uncertaintes for the bins\n    \"\"\"\n    # Bins where the reference histogram is empty/zero, are given a ratio of np.inf\n    # which means that the ratio plot will not have any entry in these bins.\n    ratio, ratio_unc = hist_ratio(\n        numerator=self.hist,\n        denominator=ref_hist,\n        numerator_unc=self.unc,\n        step=False,\n    )\n    # To use the matplotlib.step() function later on, the first bin is duplicated\n    ratio = np.append(np.array([ratio[0]]), ratio)\n    ratio_unc = np.append(np.array([ratio_unc[0]]), ratio_unc)\n\n    return (ratio, ratio_unc)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot","title":"<code>puma.histogram.HistogramPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>Histogram plot class.</p> <p>Histogram plot properties.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>int or numpy.ndarray or list</code> <p>If bins is an int, it defines the number of equal-width bins in the given range. If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths (like in numpy.histogram). By default 40</p> <code>40</code> <code>bins_range</code> <code>tuple</code> <p>Tuple of two floats, specifying the range for the binning. If bins_range is specified and bins is an integer, equal-width bins from bins_range[0] to bins_range[1] are used for the histogram (like in numpy.histogram). By default None</p> <code>None</code> <code>discrete_vals</code> <code>list</code> <p>List of values if a variable only has discrete values. If discrete_vals is specified only the bins containing these values are plotted. By default None.</p> <code>None</code> <code>norm</code> <code>bool</code> <p>Specify if the histograms are normalised, this means that histograms are divided by the total numer of counts. Therefore, the sum of the bin counts is equal to one, but NOT the area under the curve, which would be sum(bin_counts * bin_width). By default True.</p> <code>True</code> <code>logy</code> <code>bool</code> <p>Set log scale on y-axis, by default False.</p> <code>False</code> <code>bin_width_in_ylabel</code> <code>bool</code> <p>Specify if the bin width should be added to the ylabel, by default False</p> <code>False</code> <code>underoverflow</code> <code>bool</code> <p>Option to include under- and overflow values in outermost bins, by default True.</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Set the grid for the plots, by default False</p> <code>False</code> <code>stacked</code> <code>bool</code> <p>Decide, if all histograms (which are not data) are stacked, by default False</p> <code>False</code> <code>histtype</code> <code>str</code> <p>If stacked is used, define the type of histogram you would like to have, default is \"bar\"</p> <code>'bar'</code> <code>**kwargs</code> <code>puma.histogram.HistogramPlot(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If n_ratio_panels &gt; 1</p> Source code in <code>puma/histogram.py</code> <pre><code>def __init__(\n    self,\n    bins=40,\n    bins_range: tuple | None = None,\n    discrete_vals: list | None = None,\n    norm: bool = True,\n    logy: bool = False,\n    bin_width_in_ylabel: bool = False,\n    underoverflow: bool = True,\n    grid: bool = False,\n    stacked: bool = False,\n    histtype: str = \"bar\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Histogram plot properties.\n\n    Parameters\n    ----------\n    bins : int or numpy.ndarray or list, optional\n        If bins is an int, it defines the number of equal-width bins in the given\n        range. If bins is a sequence, it defines a monotonically increasing array\n        of bin edges, including the rightmost edge, allowing for non-uniform\n        bin widths (like in numpy.histogram). By default 40\n    bins_range : tuple, optional\n        Tuple of two floats, specifying the range for the binning. If bins_range is\n        specified and bins is an integer, equal-width bins from bins_range[0] to\n        bins_range[1] are used for the histogram (like in numpy.histogram).\n        By default None\n    discrete_vals : list, optional\n        List of values if a variable only has discrete values. If discrete_vals is\n        specified only the bins containing these values are plotted.\n        By default None.\n    norm : bool, optional\n        Specify if the histograms are normalised, this means that histograms are\n        divided by the total numer of counts. Therefore, the sum of the bin counts\n        is equal to one, but NOT the area under the curve, which would be\n        sum(bin_counts * bin_width). By default True.\n    logy : bool, optional\n        Set log scale on y-axis, by default False.\n    bin_width_in_ylabel : bool, optional\n        Specify if the bin width should be added to the ylabel, by default False\n    underoverflow : bool, optional\n        Option to include under- and overflow values in outermost bins, by default\n        True.\n    grid : bool, optional\n        Set the grid for the plots, by default False\n    stacked : bool, optional\n        Decide, if all histograms (which are not data) are stacked, by default False\n    histtype : str, optional\n        If stacked is used, define the type of histogram you would like to have,\n        default is \"bar\"\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n\n    Raises\n    ------\n    ValueError\n        If n_ratio_panels &gt; 1\n    \"\"\"\n    super().__init__(grid=grid, **kwargs)\n    self.logy = logy\n    self.bins = bins\n    self.bins_range = bins_range\n    self.discrete_vals = discrete_vals\n    self.bin_width_in_ylabel = bin_width_in_ylabel\n    self.norm = norm\n    self.underoverflow = underoverflow\n    self.stacked = stacked\n    self.histtype = histtype\n    self.plot_objects = {}\n    self.add_order = []\n    self.ratios_objects = {}\n    self.reference_object = None\n\n    if self.norm is True and self.stacked is True:\n        raise ValueError(\n            \"Stacked plots and normalised plots at the same time are not available.\"\n        )\n\n    if self.n_ratio_panels &gt; 1:\n        raise ValueError(\"Not more than one ratio panel supported.\")\n    self.initialise_figure()\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.add","title":"<code>add</code>","text":"<p>Adding histogram object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>histogram</code> <code>Histogram class</code> <p>Histogram curve</p> required <code>key</code> <code>str</code> <p>Unique identifier for histogram, by default None</p> <code>None</code> <code>reference</code> <code>bool</code> <p>If this histogram is used as reference for ratio calculation, by default False</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/histogram.py</code> <pre><code>def add(\n    self,\n    histogram: Histogram,\n    key: str | None = None,\n    reference: bool = False,\n):\n    \"\"\"Adding histogram object to figure.\n\n    Parameters\n    ----------\n    histogram : Histogram class\n        Histogram curve\n    key : str, optional\n        Unique identifier for histogram, by default None\n    reference : bool, optional\n        If this histogram is used as reference for ratio calculation, by default\n        False\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    if key is None:\n        key = len(self.plot_objects) + 1\n    if key in self.plot_objects:\n        raise KeyError(f\"Duplicated key {key} already used for unique identifier.\")\n\n    # Add key to histogram object\n    histogram.key = key\n    logger.debug(\"Adding histogram %s\", key)\n\n    # Set linestyle\n    if histogram.linestyle is None:\n        if histogram.is_data is True:\n            histogram.linestyle = \"\"\n        else:\n            histogram.linestyle = \"-\"\n    # Set marker\n    if histogram.marker is None:\n        if histogram.is_data is True:\n            histogram.marker = \".\"\n        else:\n            histogram.marker = \"\"\n    # Set colours\n    if histogram.colour is None:\n        histogram.colour = get_good_colours()[len(self.plot_objects)]\n    # Set alpha\n    if histogram.alpha is None:\n        histogram.alpha = 1\n    # Set linewidth\n    if histogram.linewidth is None:\n        histogram.linewidth = 1.6\n    # Set markersize\n    if histogram.markersize is None:\n        histogram.markersize = 10\n\n    self.plot_objects[key] = histogram\n    self.add_order.append(key)\n    if reference is True:\n        self.set_reference(key)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.add_bin_width_to_ylabel","title":"<code>add_bin_width_to_ylabel</code>","text":"<p>Adds the bin width to the ylabel of a histogram plot. If the bin with is smaller than 0.01, scientific notation will be used.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If plotting_done is False (therefore <code>bins</code> is not yet calculated)</p> Source code in <code>puma/histogram.py</code> <pre><code>def add_bin_width_to_ylabel(self):\n    \"\"\"Adds the bin width to the ylabel of a histogram plot. If the bin with is\n    smaller than 0.01, scientific notation will be used.\n\n    Raises\n    ------\n    ValueError\n        If plotting_done is False (therefore `bins` is not yet calculated)\n    \"\"\"\n    if self.plotting_done is False:\n        raise ValueError(\n            \"`add_bin_width_to_ylabel` should be called after plotting, since bins \"\n            \"are calculated during plotting.\"\n        )\n\n    bin_width = abs(self.bins[1] - self.bins[0])\n    if bin_width &lt; 1e-2:\n        self.ylabel = f\"{self.ylabel} / {bin_width:.0e}\"\n    else:\n        self.ylabel = f\"{self.ylabel} / {bin_width:.2f}\"\n    self.set_ylabel(self.axis_top)\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.draw","title":"<code>draw</code>","text":"<p>Draw figure.</p> <p>Parameters:</p> Name Type Description Default <code>labelpad</code> <code>int</code> <p>Spacing in points from the axes bounding box including ticks and tick labels, by default \"ratio\"</p> <code>None</code> Source code in <code>puma/histogram.py</code> <pre><code>def draw(self, labelpad: int | None = None):\n    \"\"\"Draw figure.\n\n    Parameters\n    ----------\n    labelpad : int, optional\n        Spacing in points from the axes bounding box including\n        ticks and tick labels, by default \"ratio\"\n\n    \"\"\"\n    plt_handles = self.plot()\n\n    if self.n_ratio_panels &gt; 0:\n        self.plot_ratios()\n\n    self.set_xlim(\n        self.bins[0] if self.xmin is None else self.xmin,\n        self.bins[-1] if self.xmax is None else self.xmax,\n    )\n    self.set_log()\n    self.set_y_lim()\n    self.set_xlabel()\n    self.set_tick_params()\n    self.set_ylabel(self.axis_top)\n\n    if self.n_ratio_panels &gt; 0:\n        self.set_ylabel(\n            self.ratio_axes[0],\n            self.ylabel_ratio[0],\n            align=\"center\",\n            labelpad=labelpad,\n        )\n\n    if self.bin_width_in_ylabel is True:\n        self.add_bin_width_to_ylabel()\n\n    legend_axis = self.axis_top\n\n    self.make_legend(plt_handles, ax_mpl=legend_axis)\n    self.set_title()\n\n    if self.apply_atlas_style:\n        self.atlasify()\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.get_discrete_values","title":"<code>get_discrete_values</code>","text":"<p>Get discrete values of a variable and adjust the bins accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>histogram class</code> <p>Histogram we want to calculate the bins containing discrete values for</p> required <p>Returns:</p> Name Type Description <code>bins</code> <code>numpy.ndarray</code> <p>Recalculated bins including only the discrete values</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the bin width is larger than 1 such that potentially not all discrete values are in a seperate bin</p> <code>ValueError</code> <p>If the number of bins is set to 1 such that no values can be distinguished</p> Source code in <code>puma/histogram.py</code> <pre><code>def get_discrete_values(self, elem: object):\n    \"\"\"Get discrete values of a variable and adjust the\n    bins accordingly.\n\n    Parameters\n    ----------\n    elem : histogram class\n        Histogram we want to calculate the bins containing discrete values for\n\n    Returns\n    -------\n    bins : numpy.ndarray\n        Recalculated bins including only the discrete values\n\n    Raises\n    ------\n    ValueError\n        If the bin width is larger than 1 such that potentially not\n        all discrete values are in a seperate bin\n    ValueError\n        If the number of bins is set to 1 such that no values can be\n        distinguished\n    \"\"\"\n    if len(elem.bin_edges) &gt; 1:\n        if abs(elem.bin_edges[1] - elem.bin_edges[0]) &lt;= 1:\n            indice = [\n                i\n                for i in range(len(elem.bin_edges) - 1)\n                for discrete_val in self.discrete_vals\n                if elem.bin_edges[i] &lt;= discrete_val &lt; elem.bin_edges[i + 1]\n            ]\n            elem.hist = elem.hist[indice]\n            elem.unc = elem.unc[indice]\n            elem.band = elem.band[indice]\n            bins = np.linspace(0, len(self.discrete_vals), len(self.discrete_vals) + 1)\n            elem.bin_edges = bins\n            self.axis_top.set_xticks(bins[:-1] + 0.5)\n            self.axis_top.set_xticklabels(self.discrete_vals, rotation=33)\n        else:\n            raise ValueError(\n                \"Bin width is larger than 1. Choose a binning with a bin\"\n                \" width&lt;= 1 to plot only discrete values.\"\n            )\n    else:\n        raise ValueError(\n            \"Choose a binning with more than one bin in order to plot only discrete\" \" values.\"\n        )\n\n    return bins\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.get_reference_histo","title":"<code>get_reference_histo</code>","text":"<p>Get reference histogram from list of references.</p> <p>Parameters:</p> Name Type Description Default <code>histo</code> <code>puma.histogram.Histogram</code> <p>Histogram we want to calculate the ratio for</p> required <p>Returns:</p> Name Type Description <code>reference_histo_name</code> <code>(str, int)</code> <p>Identifier of the corresponding reference histogram</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no reference histo was found or multiple matches.</p> Source code in <code>puma/histogram.py</code> <pre><code>def get_reference_histo(self, histo):\n    \"\"\"Get reference histogram from list of references.\n\n    Parameters\n    ----------\n    histo : puma.histogram.Histogram\n        Histogram we want to calculate the ratio for\n\n    Returns\n    -------\n    reference_histo_name : str, int\n        Identifier of the corresponding reference histogram\n\n    Raises\n    ------\n    ValueError\n        If no reference histo was found or multiple matches.\n    \"\"\"\n    matches = 0\n    reference_histo = None\n\n    for key in self.reference_object:\n        reference_candidate = self.plot_objects[key]\n        if histo.ratio_group is not None:\n            if histo.ratio_group == reference_candidate.ratio_group:\n                matches += 1\n                reference_histo = reference_candidate\n        else:\n            matches += 1\n            reference_histo = reference_candidate\n\n    if matches != 1:\n        raise ValueError(\n            f\"Found {matches} matching reference candidates, but only one match is\" \" allowed.\"\n        )\n\n    logger.debug(\"Reference histogram for '%s' is '%s'\", histo.key, reference_histo.key)\n\n    return reference_histo\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves. This also generates the bins of the histograms that are added to the plot. Plot objects are drawn in the same order as they were added to the plot.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments passed to matplotlib.axes.Axes.hist()</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If specified bins type is not supported.</p> Source code in <code>puma/histogram.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Plotting curves. This also generates the bins of the histograms that are\n    added to the plot. Plot objects are drawn in the same order as they were added\n    to the plot.\n\n    Parameters\n    ----------\n    **kwargs: kwargs\n        Keyword arguments passed to matplotlib.axes.Axes.hist()\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n\n    Raises\n    ------\n    ValueError\n        If specified bins type is not supported.\n    \"\"\"\n    if self.ylabel is not None and self.norm and \"norm\" not in self.ylabel.lower():\n        logger.warning(\n            \"You are plotting normalised distributions but 'norm' is not \"\n            \"included in your y-label.\"\n        )\n    plt_handles = []\n\n    # Calculate bins of stacked histograms to ensure all histograms fit in plot\n    if isinstance(self.bins, (np.ndarray, list)):\n        logger.debug(\"Using bin edges defined in plot instance.\")\n        if self.bins_range is not None:\n            logger.warning(\n                \"You defined a range for the histogram, but also an array with \"\n                \"the bin edges. The range will be ignored.\"\n            )\n    elif isinstance(self.bins, int):\n        logger.debug(\"Calculating bin edges of %i equal-width bins\", self.bins)\n        _, self.bins = np.histogram(\n            np.hstack([elem.values for elem in self.plot_objects.values()]),  # noqa: PD011\n            bins=self.bins,\n            range=self.bins_range,\n        )\n    else:\n        raise TypeError(\"Unsupported type for bins. Supported types: int, numpy.array, list\")\n\n    # Loop over all plot objects and plot them\n    bins = self.bins\n\n    # Stacked dict for the stacked histogram\n    self.stacked_dict = {\n        \"x\": [],\n        \"weights\": [],\n        \"color\": [],\n        \"unc\": None,\n    }\n\n    for key in self.add_order:\n        elem = self.plot_objects[key]\n\n        elem.bin_edges, elem.hist, elem.unc, elem.band = hist_w_unc(\n            elem.values,\n            weights=elem.weights,\n            bin_edges=elem.bin_edges,\n            sum_squared_weights=elem.sum_squared_weights,\n            bins=self.bins,\n            filled=elem.filled,\n            bins_range=self.bins_range,\n            normed=self.norm,\n            underoverflow=self.underoverflow,\n        )\n\n        # MAYBE CHECK HERE THAT self.bins and elem.bin_edges are\n        # equivalent for plotting or throw error!\n\n        if self.discrete_vals is not None:\n            # bins are recalculated for the discrete values\n            bins = self.get_discrete_values(elem)\n\n        # Check if the histogram is data\n        if elem.is_data is True:\n            # Plot data\n            self.axis_top.errorbar(\n                x=(bins[:-1] + bins[1:]) / 2,\n                y=elem.hist,\n                yerr=elem.unc if self.draw_errors else 0,\n                color=elem.colour,\n                label=elem.label,\n                alpha=elem.alpha,\n                linewidth=elem.linewidth,\n                linestyle=elem.linestyle,\n                marker=elem.marker,\n                markersize=elem.markersize,\n            )\n\n            plt_handles.append(\n                mpl.lines.Line2D(\n                    [],\n                    [],\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                    linewidth=elem.linewidth,\n                    linestyle=elem.linestyle,\n                    marker=elem.marker,\n                )\n            )\n\n        elif self.stacked:\n            self.stacked_dict[\"x\"].append(bins[:-1])\n            self.stacked_dict[\"weights\"].append(elem.hist)\n            self.stacked_dict[\"color\"].append(elem.colour)\n\n            if self.stacked_dict[\"unc\"] is None:\n                self.stacked_dict[\"unc\"] = elem.unc\n\n            else:\n                self.stacked_dict[\"unc\"] = np.sqrt(self.stacked_dict[\"unc\"] ** 2 + elem.unc**2)\n\n            # Add the element to the legend with a \"bar\"\n            plt_handles.append(\n                mpl.patches.Patch(\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                )\n            )\n\n        else:\n            # Plot histogram\n            self.axis_top.hist(\n                x=bins[:-1],\n                bins=bins,\n                weights=elem.hist,\n                histtype=elem.histtype,\n                color=elem.colour,\n                label=elem.label,\n                alpha=elem.alpha,\n                linewidth=elem.linewidth,\n                linestyle=elem.linestyle,\n                **kwargs,\n            )\n\n            # Plot histogram uncertainty\n            if self.draw_errors:\n                bottom_error = np.array([elem.band[0], *elem.band.tolist()])\n                top_error = elem.band + 2 * elem.unc\n                top_error = np.array([top_error[0], *top_error.tolist()])\n                self.axis_top.fill_between(\n                    x=elem.bin_edges,\n                    y1=bottom_error,\n                    y2=top_error,\n                    color=elem.colour,\n                    alpha=0.3,\n                    zorder=1,\n                    step=\"pre\",\n                    edgecolor=\"none\",\n                )\n\n            # Add standard \"Line\" to legend\n            plt_handles.append(\n                mpl.lines.Line2D(\n                    [],\n                    [],\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                    linewidth=elem.linewidth,\n                    linestyle=elem.linestyle,\n                    marker=elem.marker,\n                )\n            )\n\n    if self.stacked:\n        self.axis_top.hist(\n            x=self.stacked_dict[\"x\"],\n            bins=bins,\n            weights=self.stacked_dict[\"weights\"],\n            color=self.stacked_dict[\"color\"],\n            histtype=self.histtype,\n            alpha=elem.alpha,\n            linewidth=elem.linewidth,\n            linestyle=elem.linestyle,\n            stacked=self.stacked,\n            **kwargs,\n        )\n\n        # Create a total weights entry to correctly plot the ratio\n        # Total weights is here the y-value of all contributions stacked\n        self.stacked_dict[\"total_weights\"] = np.sum(self.stacked_dict[\"weights\"], axis=0)\n\n    # Check if errors should be drawn\n    # If stacked is true, plot the combined uncertainty\n    if self.draw_errors and self.stacked:\n        # Calculate the y-values of the bottom error\n        bottom_error = self.stacked_dict[\"total_weights\"] - self.stacked_dict[\"unc\"]\n        bottom_error = np.array([bottom_error[0], *bottom_error.tolist()])\n\n        # Calculate the y-values of the top error\n        top_error = self.stacked_dict[\"total_weights\"] + self.stacked_dict[\"unc\"]\n        top_error = np.array([top_error[0], *top_error.tolist()])\n\n        # Fill the space between bottom and top with the unc. band\n        self.axis_top.fill_between(\n            x=elem.bin_edges,\n            y1=bottom_error,\n            y2=top_error,\n            alpha=0.5,\n            zorder=1,\n            step=\"pre\",\n            facecolor=\"white\",\n            edgecolor=\"black\",\n            linewidth=0,\n            hatch=\"/////\",\n        )\n\n        # Add a label for the unc. in the legend\n        plt_handles.append(\n            mpl.patches.Patch(\n                facecolor=\"white\",\n                edgecolor=\"black\",\n                label=\"Stat. unc.\",\n                linewidth=0,\n                alpha=0.5,\n                hatch=\"/////\",\n            )\n        )\n\n    if self.discrete_vals is not None:\n        self.bins = bins\n\n    self.plotting_done = True\n    return plt_handles\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.plot_ratios","title":"<code>plot_ratios</code>","text":"<p>Plotting ratio histograms.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no reference histogram is defined</p> Source code in <code>puma/histogram.py</code> <pre><code>def plot_ratios(self):\n    \"\"\"Plotting ratio histograms.\n\n    Raises\n    ------\n    ValueError\n        If no reference histogram is defined\n    \"\"\"\n    # Check if this is a stacked plot\n    # Plot ratio only between data and the stacked histos\n    for key in self.add_order:\n        # Get the object which is to be plotted\n        elem = self.plot_objects[key]\n\n        if elem.bin_edges is None:\n            raise ValueError(\n                \"Bin edges of plot object not set. This is done in \"\n                \"histogram_plot.plot(), so it has to be called before \"\n                \"plot_ratios() is called.\"\n            )\n\n        # Check if this is going to be Data/MC (Data/stacked plot)\n        if self.stacked:\n            # Check this is data\n            if not elem.is_data:\n                continue\n\n            # Using the total weights (full stacked histo) as reference for data\n            ratio, ratio_unc = elem.divide_data_mc(\n                ref_hist=self.stacked_dict[\"total_weights\"],\n            )\n\n        else:\n            if self.reference_object is None:\n                raise ValueError(\"Please specify a reference curve.\")\n\n            ratio, ratio_unc = elem.divide(self.get_reference_histo(elem))\n\n        # Plot the ratio values with the step function\n        if self.stacked:\n            if elem.is_data is True:\n                self.ratio_axes[0].errorbar(\n                    x=(elem.bin_edges[:-1] + elem.bin_edges[1:]) / 2,\n                    y=ratio[1:],\n                    yerr=ratio_unc[1:] if self.draw_errors else 0,\n                    color=elem.colour,\n                    label=elem.label,\n                    alpha=elem.alpha,\n                    linewidth=elem.linewidth,\n                    linestyle=elem.linestyle,\n                    marker=elem.marker,\n                    markersize=elem.markersize,\n                )\n\n        else:\n            self.ratio_axes[0].step(\n                x=elem.bin_edges,\n                y=ratio,\n                color=elem.colour,\n                linewidth=elem.linewidth,\n                linestyle=elem.linestyle,\n            )\n\n            # Plot the ratio uncertainty\n            if self.draw_errors:\n                self.ratio_axes[0].fill_between(\n                    x=elem.bin_edges,\n                    y1=np.nan_to_num(ratio - ratio_unc, nan=0, posinf=0),\n                    y2=np.nan_to_num(ratio + ratio_unc, nan=0, posinf=0),\n                    color=elem.colour,\n                    alpha=0.3,\n                    zorder=1,\n                    step=\"pre\",\n                    edgecolor=\"none\",\n                )\n\n    if self.stacked and self.draw_errors:\n        self.ratio_axes[0].fill_between(\n            x=elem.bin_edges,\n            y1=np.nan_to_num((ratio - ratio_unc) / ratio, nan=0, posinf=0),\n            y2=np.nan_to_num((ratio + ratio_unc) / ratio, nan=0, posinf=0),\n            color=elem.colour,\n            alpha=0.3,\n            zorder=1,\n            step=\"pre\",\n            edgecolor=\"none\",\n        )\n</code></pre>"},{"location":"api/histogram/#puma.histogram.HistogramPlot.set_reference","title":"<code>set_reference</code>","text":"<p>Setting the reference histogram curves used in the ratios.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier of histogram object</p> required Source code in <code>puma/histogram.py</code> <pre><code>def set_reference(self, key: str):\n    \"\"\"Setting the reference histogram curves used in the ratios.\n\n    Parameters\n    ----------\n    key : str\n        Unique identifier of histogram object\n    \"\"\"\n    if self.reference_object is None:\n        self.reference_object = [key]\n    else:\n        self.reference_object.append(key)\n    logger.debug(\"Adding '%s' to reference histogram(s)\", key)\n</code></pre>"},{"location":"api/int_eff/","title":"Integrated Efficiency","text":""},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiency","title":"<code>puma.integrated_eff.IntegratedEfficiency</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>Represent a single IntegratedEfficiency curve.</p> <p>Initialise properties of IntegratedEfficiency object.</p> <p>Parameters:</p> Name Type Description Default <code>disc_sig</code> <code>numpy.array</code> <p>Discriminant values for signal</p> required <code>disc_bkg</code> <code>numpy.array</code> <p>Discriminant values for background</p> required <code>key</code> <code>str</code> <p>Identifier for IntegratedEfficiency e.g. tagger, by default None</p> <code>None</code> <code>n_vals</code> <code>int</code> <p>Number of values to calculate the efficiency at, by default 500</p> <code>500</code> <code>tagger</code> <code>str</code> <p>Tagger name, by default None</p> <code>None</code> <code>flavour</code> <code>str or ftag.Label</code> <p>Flavour label of the jets, by default None</p> <code>None</code> <code>**kwargs</code> <code>puma.integrated_eff.IntegratedEfficiency(kwargs)</code> <p>Keyword arguments passed to <code>puma.PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>sig_eff</code> and <code>bkg_rej</code> have a different shape</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def __init__(\n    self,\n    disc_sig: np.ndarray,\n    disc_bkg: np.ndarray,\n    key: str | None = None,\n    n_vals: int = 500,\n    tagger: str | None = None,\n    flavour: str | Label = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialise properties of IntegratedEfficiency object.\n\n    Parameters\n    ----------\n    disc_sig : np.array\n        Discriminant values for signal\n    disc_bkg : np.array\n        Discriminant values for background\n    key : str\n        Identifier for IntegratedEfficiency e.g. tagger, by default None\n    n_vals : int, optional\n        Number of values to calculate the efficiency at, by default 500\n    tagger : str, optional\n        Tagger name, by default None\n    flavour : str or Label, optional\n        Flavour label of the jets, by default None\n    **kwargs : kwargs\n        Keyword arguments passed to `puma.PlotLineObject`\n\n    Raises\n    ------\n    ValueError\n        If `sig_eff` and `bkg_rej` have a different shape\n    \"\"\"\n    super().__init__(**kwargs)\n    self.disc_sig = np.asarray(disc_sig)\n    self.disc_bkg = np.asarray(disc_bkg)\n    self.n_vals = n_vals\n    self.tagger = tagger\n    self.key = key\n    self.flavour = Flavours[flavour] if isinstance(flavour, str) else flavour\n    if self.label is None and self.flavour is not None:\n        self.label = self.flavour.label\n    self._calc_profile()\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiency._calc_profile","title":"<code>_calc_profile</code>","text":"<p>Calculate the profile of the integrated efficiency curve.</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def _calc_profile(self):\n    \"\"\"Calculate the profile of the integrated efficiency curve.\"\"\"\n    self.eff, self.x = calc_eff(\n        self.disc_sig,\n        self.disc_bkg,\n        np.linspace(0, 1, self.n_vals),\n        return_cuts=True,\n    )\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot","title":"<code>puma.integrated_eff.IntegratedEfficiencyPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>IntegratedEfficiencyPlot class.</p> <p>IntegratedEfficiency plot properties.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>True</code> <code>**kwargs</code> <code>puma.integrated_eff.IntegratedEfficiencyPlot(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/integrated_eff.py</code> <pre><code>def __init__(self, grid: bool = True, **kwargs) -&gt; None:\n    \"\"\"IntegratedEfficiency plot properties.\n\n    Parameters\n    ----------\n    grid : bool, optional\n        Set the grid for the plots.\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n    \"\"\"\n    super().__init__(grid=grid, **kwargs)\n    self.int_effs = {}\n    self.tagger_ls = {}\n    self.label_colours = {}\n    self.leg_tagger_labels = {}\n    self.initialise_figure()\n    self.disc_min, self.disc_max = (1e3, -1e3)\n    self.default_linestyles = get_good_linestyles()\n    self.legend_flavs = None\n    self.leg_tagger_loc = \"lower left\"\n\n    self.ymin = 0\n    self.ymax = 1.2\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.add","title":"<code>add</code>","text":"<p>Adding puma.Roc object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>int_effs</code> <code>puma.IntegratedEfficiency</code> <p>IntegratedEfficiency curve</p> required <code>key</code> <code>str</code> <p>Unique identifier for IntegratedEfficiency curve, by default None</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def add(self, int_eff: object, key: str | None = None):\n    \"\"\"Adding puma.Roc object to figure.\n\n    Parameters\n    ----------\n    int_effs : puma.IntegratedEfficiency\n        IntegratedEfficiency curve\n    key : str, optional\n        Unique identifier for IntegratedEfficiency curve, by default None\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    if key is None:\n        key = len(self.int_effs) + 1\n    if key in self.int_effs:\n        raise KeyError(f\"Duplicated key {key} already used for roc unique identifier.\")\n\n    self.int_effs[key] = int_eff\n    # set linestyle\n    if int_eff.tagger not in self.tagger_ls:\n        self.tagger_ls[int_eff.tagger] = (\n            self.default_linestyles[len(self.tagger_ls)]\n            if int_eff.linestyle is None\n            else int_eff.linestyle\n        )\n    elif int_eff.linestyle != self.tagger_ls[int_eff.tagger] and int_eff.linestyle is not None:\n        logger.warning(\n            \"You specified a different linestyle for the same tagger\"\n            \" %s. This will lead to a mismatch in the line colours\"\n            \" and the legend.\",\n            int_eff.tagger,\n        )\n    if int_eff.linestyle is None:\n        int_eff.linestyle = self.tagger_ls[int_eff.tagger]\n\n    # set colours\n    if int_eff.label not in self.label_colours:\n        if int_eff.flavour is not None:\n            self.label_colours[int_eff.label] = int_eff.flavour.colour\n        else:\n            curr_colours = set(self.label_colours.values())\n            possible_colours = set(get_good_colours()) - curr_colours\n            self.label_colours[int_eff.label] = (\n                possible_colours.pop() if int_eff.colour is None else int_eff.colour\n            )\n    elif int_eff.colour != self.label_colours[int_eff.label] and int_eff.colour is not None:\n        logger.warning(\n            \"You specified a different colour for the same label\"\n            \" %s. This will lead to a mismatch in the line colours\"\n            \" and the legend.\",\n            int_eff.label,\n        )\n    if int_eff.colour is None:\n        int_eff.colour = self.label_colours[int_eff.label]\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.draw","title":"<code>draw</code>","text":"<p>Draw plotting.</p> <p>Parameters:</p> Name Type Description Default <code>x_label</code> <code>str</code> <p>x-axis label, by default Discriminant</p> <code>'Discriminant'</code> Source code in <code>puma/integrated_eff.py</code> <pre><code>def draw(\n    self,\n    x_label: str = \"Discriminant\",\n):\n    \"\"\"Draw plotting.\n\n    Parameters\n    ----------\n    x_label : str, optional\n        x-axis label, by default Discriminant\n    \"\"\"\n    plt_handles = self.plot()\n    xmin, xmax = self.get_xlim_auto()\n\n    self.set_xlim(\n        xmin if self.xmin is None else self.disc_min,\n        xmax if self.xmax is None else self.disc_max,\n    )\n    self.set_title()\n    self.set_y_lim()\n    # self.set_log()\n    self.set_y_lim()\n    self.set_xlabel(label=x_label)\n    self.set_ylabel(self.axis_top, label=\"Integrated efficiency\")\n\n    self.make_legend(plt_handles)\n\n    self.plotting_done = True\n    if self.apply_atlas_style is True:\n        self.atlasify()\n        # atlasify can only handle one legend. Therefore, we remove the frame of\n        # the second legend by hand\n        if self.legend_flavs is not None:\n            self.legend_flavs.set_frame_on(False)\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.get_xlim_auto","title":"<code>get_xlim_auto</code>","text":"<p>Returns min and max efficiency values.</p> <p>Returns:</p> Type Description <code>float</code> <p>Min and max efficiency values</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def get_xlim_auto(self):\n    \"\"\"Returns min and max efficiency values.\n\n    Returns\n    -------\n    float\n        Min and max efficiency values\n    \"\"\"\n    for elem in self.int_effs.values():\n        self.disc_min = min(np.min(elem.x), self.disc_min)\n        self.disc_max = max(np.max(elem.x), self.disc_max)\n\n    return self.disc_min, self.disc_max\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.make_legend","title":"<code>make_legend</code>","text":"<p>Make legend.</p> <p>Parameters:</p> Name Type Description Default <code>handles</code> <code>list</code> <p>List of handles</p> required Source code in <code>puma/integrated_eff.py</code> <pre><code>def make_legend(self, handles: list):\n    \"\"\"Make legend.\n\n    Parameters\n    ----------\n    handles : list\n        List of handles\n    \"\"\"\n    line_list_tagger = [\n        mpl.lines.Line2D(\n            [],\n            [],\n            color=\"k\",\n            linestyle=self.tagger_ls[tagger],\n            label=tagger,\n        )\n        for tagger in self.tagger_ls\n    ]\n    self.legend_flavs = self.axis_top.legend(\n        handles=line_list_tagger,\n        labels=[handle.get_label() for handle in line_list_tagger],\n        loc=self.leg_tagger_loc,\n        fontsize=self.leg_fontsize,\n        ncol=self.leg_ncol,\n    )\n    self.axis_top.add_artist(self.legend_flavs)\n    # Get the labels for the legends\n    labels_list = []\n    lines_list = []\n\n    for line in handles:\n        if line.get_label() not in labels_list:\n            labels_list.append(line.get_label())\n            lines_list.append(line)\n\n    # Define the legend\n    self.axis_top.legend(\n        handles=lines_list,\n        labels=labels_list,\n        loc=self.leg_loc,\n        fontsize=self.leg_fontsize,\n        ncol=self.leg_ncol,\n    )\n</code></pre>"},{"location":"api/int_eff/#puma.integrated_eff.IntegratedEfficiencyPlot.plot","title":"<code>plot</code>","text":"<p>Plotting integrated efficiency curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments passed to plt.axis.plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/integrated_eff.py</code> <pre><code>def plot(self, **kwargs) -&gt; mpl.lines.Line2D:\n    \"\"\"Plotting integrated efficiency curves.\n\n    Parameters\n    ----------\n    **kwargs: kwargs\n        Keyword arguments passed to plt.axis.plot\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n    \"\"\"\n    plt_handles = []\n    for key, elem in self.int_effs.items():\n        plt_handles += self.axis_top.plot(\n            elem.x,\n            elem.eff,\n            linestyle=elem.linestyle,\n            color=elem.colour,\n            label=elem.label if elem is not None else key,\n            zorder=2,\n            **kwargs,\n        )\n    return plt_handles\n</code></pre>"},{"location":"api/matshow_plot/","title":"Matshow plot","text":""},{"location":"api/matshow_plot/#puma.matshow.MatshowPlot","title":"<code>puma.matshow.MatshowPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>Plot Matrix class.</p> <p>Plot a matrix with matplotlib matshow.</p> <p>Parameters:</p> Name Type Description Default <code>x_ticklabels</code> <code>list | None</code> <p>Names of the matrix's columns; if None, indices are shown. by default None</p> <code>None</code> <code>x_ticks_rotation</code> <code>int</code> <p>Rotation of the columns' names, by default 90</p> <code>90</code> <code>y_ticklabels</code> <code>list | None</code> <p>Names of the matrix's rows; if None, indices are shown. by default None</p> <code>None</code> <code>show_entries</code> <code>bool</code> <p>If True, show matrix entries as numbers in the matrix pixels. by default True</p> <code>True</code> <code>show_percentage</code> <code>bool</code> <p>If True, if matrix entries are percentages (i.e. numbers in [0,1]), format them as percentages. by default False</p> <code>False</code> <code>text_color_threshold</code> <code>float</code> <p>threshold on the relative luminance of the colormap bkg color after which the text color switches to black, to allow better readability on lighter cmap bkg colors. If 1, all text is white; if 0, all text is black. by default 0.408</p> <code>0.408</code> <code>colormap</code> <code>matplotlib.pyplot.cm</code> <p>Colormap for the plot, by default <code>plt.cm.Oranges</code></p> <code>matplotlib.pyplot.cm.Oranges</code> <code>show_cbar</code> <code>bool</code> <p>Whether to plot the colorbar or not, by default True</p> <code>True</code> <code>cbar_label</code> <code>str | None</code> <p>Label of the colorbar, by default None</p> <code>None</code> <code>**kwargs</code> <code>puma.matshow.MatshowPlot(kwargs)</code> <p>Keyword arguments for <code>puma.PlotObject</code></p> <code>{}</code> Example <p>matrix_plotter = MatshowPlot() mat = np.random.rand(4, 3) matrix_plotter.draw(mat)</p> Source code in <code>puma/matshow.py</code> <pre><code>def __init__(\n    self,\n    x_ticklabels: list | None = None,\n    x_ticks_rotation: int = 90,\n    y_ticklabels: list | None = None,\n    show_entries: bool = True,\n    show_percentage: bool = False,\n    text_color_threshold: float = 0.408,\n    colormap: plt.cm = plt.cm.Oranges,\n    show_cbar: bool = True,\n    cbar_label: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Plot a matrix with matplotlib matshow.\n\n    Parameters\n    ----------\n    x_ticklabels : list | None, optional\n        Names of the matrix's columns; if None, indices are shown. by default None\n    x_ticks_rotation : int, optional\n        Rotation of the columns' names, by default 90\n    y_ticklabels : list | None, optional\n        Names of the matrix's rows; if None, indices are shown. by default None\n    show_entries : bool, optional\n        If True, show matrix entries as numbers in the matrix pixels. by default True\n    show_percentage : bool, optional\n        If True, if matrix entries are percentages (i.e. numbers in [0,1]), format them as\n        percentages. by default False\n    text_color_threshold : float, optional\n        threshold on the relative luminance of the colormap bkg color after which the text color\n        switches to black, to allow better readability on lighter cmap bkg colors.\n        If 1, all text is white; if 0, all text is black. by default 0.408\n    colormap : plt.cm, optional\n        Colormap for the plot, by default `plt.cm.Oranges`\n    show_cbar : bool, optional\n        Whether to plot the colorbar or not, by default True\n    cbar_label : str | None, optional\n        Label of the colorbar, by default None\n    **kwargs : kwargs\n        Keyword arguments for `puma.PlotObject`\n\n    Example\n    -------\n    &gt;&gt;&gt; matrix_plotter = MatshowPlot()\n    &gt;&gt;&gt; mat = np.random.rand(4, 3)\n    &gt;&gt;&gt; matrix_plotter.draw(mat)\n    \"\"\"\n    super().__init__(**kwargs)\n\n    self.x_ticklabels = x_ticklabels\n    self.x_ticks_rotation = x_ticks_rotation\n    self.y_ticklabels = y_ticklabels\n    self.show_entries = show_entries\n    self.show_percentage = show_percentage\n    self.text_color_threshold = text_color_threshold\n    self.colormap = colormap\n    self.show_cbar = show_cbar\n    self.cbar_label = cbar_label\n\n    # Specifying figsize if not specified by user\n    if self.figsize is None:\n        self.figsize = (10, 10.5)\n    self.initialise_figure()\n</code></pre>"},{"location":"api/matshow_plot/#puma.matshow.MatshowPlot.__get_luminance","title":"<code>__get_luminance</code>","text":"<p>Calculate the relative luminance of a color according to W3C standards. For the details of the conversion see: https://www.w3.org/WAI/GL/wiki/Relative_luminance .</p> <p>Parameters:</p> Name Type Description Default <code>rgbColor</code> <code>tuple</code> <p>(r,g,b,a) color (returned from <code>plt.cm</code> colormap)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Relative luminance of the color.</p> Source code in <code>puma/matshow.py</code> <pre><code>def __get_luminance(self, rgbaColor):\n    \"\"\"Calculate the relative luminance of a color according to W3C standards.\n    For the details of the conversion see: https://www.w3.org/WAI/GL/wiki/Relative_luminance .\n\n    Parameters\n    ----------\n    rgbColor : tuple\n        (r,g,b,a) color (returned from `plt.cm` colormap)\n\n    Returns\n    -------\n    float\n        Relative luminance of the color.\n    \"\"\"\n    # Converting to np.ndarray, ignoring alpha channel\n    rgbaColor = np.array(rgbaColor[:-1])\n    rgbaColor = np.where(\n        rgbaColor &lt;= 0.03928, rgbaColor / 12.92, ((rgbaColor + 0.055) / 1.055) ** 2.4\n    )\n    weights = np.array([0.2126, 0.7152, 0.0722])\n    return np.dot(rgbaColor, weights)\n</code></pre>"},{"location":"api/matshow_plot/#puma.matshow.MatshowPlot.__plot","title":"<code>__plot</code>","text":"<p>Plot the Matrix.</p> Source code in <code>puma/matshow.py</code> <pre><code>def __plot(self, matrix):\n    \"\"\"Plot the Matrix.\"\"\"\n    n_cols = matrix.shape[1]\n    n_rows = matrix.shape[0]\n\n    im = self.axis_top.matshow(matrix, cmap=self.colormap)\n\n    # If mat entries have to be plotted\n    if self.show_entries:\n        # Mapping mat values in [0,1], as it's done by matplotlib\n        # to associate them to the colors of the colormap\n        normMat = matrix - np.min(matrix)\n        normMat /= np.max(matrix) - np.min(matrix)\n\n        # Adding text values in the matrix pixels\n        for i in range(n_rows):\n            for j in range(n_cols):\n                # Choosing the text color: black if color is light, white if color is dark\n                # Getting the bkg color from the cmap\n                color = self.colormap(normMat[i, j])\n                # Calculating the bkg relative luminance\n                luminance = self.__get_luminance(color)\n                # Choosing the appropriate color\n                color = \"white\" if luminance &lt;= self.text_color_threshold else \"black\"\n\n                # If matrix entry is an int, do not show decimals\n                if m.modf(matrix[i, j])[0] == 0:\n                    text = f\"{matrix[i, j]:.0f}\"\n                # Else, round it or show it as percentage\n                else:\n                    text = (\n                        f\"{matrix[i, j]:.3f}\"\n                        if not self.show_percentage\n                        else f\"{matrix[i, j] * 100:.0f}%\"\n                    )\n                # Plotting text\n                self.axis_top.text(\n                    x=j,\n                    y=i,\n                    s=text,\n                    va=\"center\",\n                    ha=\"center\",\n                    c=color,\n                    fontsize=self.fontsize,\n                )\n    if self.show_cbar:\n        # Plotting colorbar\n        cbar = self.fig.colorbar(im)\n        # If using percentages, converting cbar labels to percentages\n        if self.show_entries and self.show_percentage:\n            minMat = np.min(matrix)\n            maxMat = np.max(matrix)\n            cbar.set_ticks(\n                ticks=np.linspace(minMat, maxMat, 5),\n                labels=[f\"{i}%\" for i in np.round(np.linspace(minMat, maxMat, 5) * 100, 2)],\n                fontsize=self.fontsize,\n            )\n        if self.cbar_label is not None:\n            cbar.ax.set_ylabel(self.cbar_label, fontsize=self.fontsize)\n\n    # Setting tick labels\n    if self.x_ticklabels is None:\n        self.x_ticklabels = [str(i) for i in range(n_cols)]\n        logger.info(\"MatshowPlot: no x_ticklabels given, using indices instead.\")\n    if self.y_ticklabels is None:\n        self.y_ticklabels = [str(i) for i in range(n_rows)]\n        logger.info(\"MatshowPlot: no y_ticklabels given, using indices instead.\")\n\n    # Writing class names on the axes\n    positions = list(range(n_cols))\n    self.axis_top.set_xticks(\n        np.array(positions) + 0.25,\n        labels=self.x_ticklabels,\n        rotation=self.x_ticks_rotation,\n        fontsize=self.fontsize,\n        ha=\"right\",\n    )\n    positions = list(range(n_rows))\n    self.axis_top.set_yticks(positions, labels=self.y_ticklabels, fontsize=self.fontsize)\n    # Put xticks to the bottom\n    self.axis_top.xaxis.tick_bottom()\n\n    # Finished plotting, can apply atlas_style\n    self.plotting_done = True\n    # Applying atlas style\n    if self.apply_atlas_style:\n        # Apply ATLAS style\n        self.atlasify()\n        # Mirror y axis to have the diagonal in the common orientation\n        self.axis_top.invert_yaxis()\n\n    # Disable x and y ticks for better appearance\n    self.axis_top.tick_params(\"x\", which=\"both\", top=False, bottom=False)\n    self.axis_top.tick_params(\"y\", which=\"both\", right=False, left=False)\n    # Disable grid for better appearance\n    self.axis_top.grid(False)\n\n    # Setting title and label\n    self.set_xlabel()\n    self.set_ylabel(self.axis_top)\n    self.set_title()\n</code></pre>"},{"location":"api/matshow_plot/#puma.matshow.MatshowPlot.draw","title":"<code>draw</code>","text":"<p>Draw a matrix with the class customized appearance.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>numpy.ndarray</code> <p>The matrix to be plotted.</p> required Source code in <code>puma/matshow.py</code> <pre><code>def draw(self, matrix):\n    \"\"\"Draw a matrix with the class customized appearance.\n\n    Parameters\n    ----------\n    matrix : np.ndarray\n        The matrix to be plotted.\n    \"\"\"\n    # Checking size consistency of ticklabels\n    if self.x_ticklabels is not None:\n        assert (\n            len(self.x_ticklabels) == matrix.shape[1]\n        ), \"MatshowPlot: mismatch between x_tickslabels and number of columns in the matrix.\"\n\n    if self.y_ticklabels is not None:\n        assert (\n            len(self.y_ticklabels) == matrix.shape[0]\n        ), \"MatshowPlot: mismatch between y_tickslabels and number of rows in the matrix.\"\n\n    self.__plot(matrix)\n</code></pre>"},{"location":"api/pie_chart/","title":"Pie Chart","text":""},{"location":"api/pie_chart/#puma.pie.PiePlot","title":"<code>puma.pie.PiePlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>Pie plot class.</p> <p>Initialise the pie plot.</p> <p>Parameters:</p> Name Type Description Default <code>wedge_sizes</code> <code>1D array like</code> <p>The size of the wedges. Will be translated into the fractions automatically. So they don't have to add up to 1 or 100. The fractional area of each wedge is given by x/sum(x).</p> required <code>colours</code> <code>list</code> <p>List of colours for the separate wedges. You have to specify as many colours as you have wedges. Instead, you can also specify a colour scheme with the <code>colour_scheme</code> argument, by default None</p> <code>None</code> <code>colour_scheme</code> <code>str</code> <p>Name of the colour schemes as defined in puma.utils.get_good_pie_colours, by default None</p> <code>None</code> <code>labels</code> <code>list</code> <p>A sequence of strings providing the labels for each wedge, by default None</p> <code>None</code> <code>draw_legend</code> <code>bool</code> <p>If True, a legend will be drawn on the right side of the plot. If False, the labels will be drawn directly to the wedges. By default True</p> <code>False</code> <code>mpl_pie_kwargs</code> <code>dict</code> <p>Keyword arguments that are handed to the matplotlib.pyplot.pie function. All arguments are allowed, except [<code>x</code>, <code>labels</code>, <code>colors</code>], by default None</p> <code>None</code> <code>**kwargs</code> <code>puma.pie.PiePlot(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/pie.py</code> <pre><code>def __init__(\n    self,\n    wedge_sizes,\n    colours: list | None = None,\n    colour_scheme: str | None = None,\n    labels: list | None = None,\n    draw_legend: bool = False,\n    mpl_pie_kwargs: dict | None = None,\n    **kwargs,\n):\n    \"\"\"Initialise the pie plot.\n\n    Parameters\n    ----------\n    wedge_sizes : 1D array like\n        The size of the wedges. Will be translated into the fractions automatically.\n        So they don't have to add up to 1 or 100. The fractional area of each\n        wedge is given by x/sum(x).\n    colours : list, optional\n        List of colours for the separate wedges. You have to specify as many\n        colours as you have wedges. Instead, you can also specify a colour scheme\n        with the `colour_scheme` argument, by default None\n    colour_scheme : str, optional\n        Name of the colour schemes as defined in puma.utils.get_good_pie_colours,\n        by default None\n    labels : list, optional\n        A sequence of strings providing the labels for each wedge, by default None\n    draw_legend : bool, optional\n        If True, a legend will be drawn on the right side of the plot.\n        If False, the labels will be drawn directly to the wedges. By default True\n    mpl_pie_kwargs : dict, optional\n        Keyword arguments that are handed to the matplotlib.pyplot.pie function.\n        All arguments are allowed, except [`x`, `labels`, `colors`], by default None\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n    \"\"\"\n    super().__init__(vertical_split=draw_legend, **kwargs)\n    self.wedge_sizes = wedge_sizes\n    self.draw_legend = draw_legend\n\n    # set colours\n    if colours is not None:\n        logger.info(\"Using specified colours list.\")\n        self.colours = colours\n    else:\n        # Using one of the colour schemes defined in puma.utils.get_good_pie_colours\n        logger.info(\"Using specified colour scheme (%s).\", colour_scheme)\n        self.colours = get_good_pie_colours(colour_scheme)[: len(wedge_sizes)]\n\n    self.labels = labels if labels is not None else [\"\" for i in range(len(wedge_sizes))]\n\n    # Add some good defaults if not specified:\n    self.mpl_pie_kwargs = {\n        \"autopct\": \"%1.1f%%\",\n        \"startangle\": 90,\n    }\n    # If mpl.pie kwargs were specified, overwrite the defaults\n    if mpl_pie_kwargs is not None:\n        for key, value in mpl_pie_kwargs.items():\n            self.mpl_pie_kwargs[key] = value\n\n    self.initialise_figure()\n    self.plot()\n</code></pre>"},{"location":"api/pie_chart/#puma.pie.PiePlot.plot","title":"<code>plot</code>","text":"<p>Plot the pie chart.</p> Source code in <code>puma/pie.py</code> <pre><code>def plot(\n    self,\n):\n    \"\"\"Plot the pie chart.\"\"\"\n    self.axis_top.pie(\n        x=self.wedge_sizes,\n        labels=None if self.draw_legend else self.labels,\n        colors=self.colours,\n        **self.mpl_pie_kwargs,\n    )\n\n    # If the legend should be drawn, get the handles and plot it on the right axis\n    if self.draw_legend:\n        plt_handles = []\n        for pie_label, pie_colour in zip(self.labels, self.colours):\n            plt_handles.append(\n                mpl.patches.Patch(\n                    label=pie_label,\n                    color=pie_colour,\n                )\n            )\n        self.axis_leg.axis(\"off\")\n        self.make_legend(plt_handles, ax_mpl=self.axis_leg)\n    else:\n        self.axis_top.axis(\"equal\")\n\n    self.plotting_done = True\n\n    if self.apply_atlas_style:\n        self.atlasify()\n        # Remove the legend that is automatically created by atlasify\n        if not self.draw_legend:\n            self.axis_top.legend().remove()\n\n    self.set_title()\n    self.set_y_lim()\n</code></pre>"},{"location":"api/plot_base/","title":"Plot Base","text":""},{"location":"api/plot_base/#puma.plot_base.PlotLineObject","title":"<code>puma.plot_base.PlotLineObject</code>  <code>dataclass</code>","text":"<p>Base data class defining properties of a plot object.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum value of the x-axis, by default None</p> <code>None</code> <code>xmax</code> <code>float</code> <p>Maximum value of the x-axis, by default None</p> <code>None</code> <code>colour</code> <code>str</code> <p>Colour of the object, by default None</p> <code>None</code> <code>label</code> <code>str</code> <p>Label of object, by default None</p> <code>None</code> <code>linestyle</code> <code>str</code> <p>Linestyle following numpy style, by default None</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Value for visibility of the plot lines, by default None</p> <code>None</code> <code>marker</code> <code>str</code> <p>Marker that is used in the plot. For example an x. By default None</p> <code>None</code> <code>markersize</code> <code>int</code> <p>Size of the marker. By default None</p> <code>None</code> <code>markeredgewidth</code> <code>int</code> <p>Edge width of the marker. By default None</p> <code>None</code> <code>is_marker</code> <code>bool</code> <p>Bool, to give info about if this is a marker or a line. By default None</p> <code>None</code>"},{"location":"api/plot_base/#puma.plot_base.PlotObject","title":"<code>puma.plot_base.PlotObject</code>  <code>dataclass</code>","text":"<p>Data base class defining properties of a plot object.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the plot, by default \"\"</p> <code>''</code> <code>draw_errors</code> <code>bool</code> <p>Draw statistical uncertainty on the lines, by default True</p> <code>True</code> <code>xmin</code> <code>float</code> <p>Minimum value of the x-axis, by default None</p> <code>None</code> <code>xmax</code> <code>float</code> <p>Maximum value of the x-axis, by default None</p> <code>None</code> <code>ymin</code> <code>float</code> <p>Minimum value of the y-axis, by default None</p> <code>None</code> <code>ymax</code> <code>float</code> <p>Maximum value of the y-axis, by default None</p> <code>None</code> <code>ymin_ratio</code> <code>list</code> <p>Set the lower y limit of each of the ratio subplots, by default None.</p> <code>None</code> <code>ymax_ratio</code> <code>list</code> <p>Set the upper y limit of each of the ratio subplots, by default None.</p> <code>None</code> <code>y_scale</code> <code>float</code> <p>Scaling up the y axis, e.g. to fit the ATLAS Tag. Applied if ymax not defined, by default 1.3</p> <code>1.3</code> <code>logx</code> <code>bool</code> <p>Set the log of x-axis, by default False</p> <code>False</code> <code>logy</code> <code>bool</code> <p>Set log of y-axis of main panel, by default True</p> <code>True</code> <code>xlabel</code> <code>str</code> <p>Label of the x-axis, by default None</p> <code>None</code> <code>ylabel</code> <code>str</code> <p>Label of the y-axis, by default None</p> <code>None</code> <code>ylabel_ratio</code> <code>list</code> <p>List of labels for the y-axis in the ratio plots, by default \"Ratio\"</p> <code>None</code> <code>label_fontsize</code> <code>int</code> <p>Used fontsize in label, by default 12</p> <code>12</code> <code>fontsize</code> <code>int</code> <p>Used fontsize, by default 10</p> <code>10</code> <code>n_ratio_panels</code> <code>int</code> <p>Amount of ratio panels between 0 and 2, by default 0</p> <code>0</code> <code>vertical_split</code> <code>bool</code> <p>Set to False if you would like to split the figure horizonally. If set to True the figure is split vertically (e.g for pie chart). By default False.</p> <code>False</code> <code>figsize</code> <code>(float, float)</code> <p>Tuple of figure size <code>(width, height)</code> in inches, by default (8, 6)</p> <code>None</code> <code>dpi</code> <code>int</code> <p>DPI used for plotting, by default 400</p> <code>400</code> <code>transparent</code> <code>bool</code> <p>Specify if the background of the plot should be transparent, by default False</p> <code>False</code> <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>True</code> <code>leg_fontsize</code> <code>int</code> <p>Fontsize of the legend, by default 10</p> <code>None</code> <code>leg_loc</code> <code>str</code> <p>Position of the legend in the plot, by default \"upper right\"</p> <code>'upper right'</code> <code>leg_ncol</code> <code>int</code> <p>Number of legend columns, by default 1</p> <code>1</code> <code>leg_linestyle_loc</code> <code>str</code> <p>Position of the linestyle legend in the plot, by default \"upper center\"</p> <code>'upper center'</code> <code>apply_atlas_style</code> <code>bool</code> <p>Apply ATLAS style for matplotlib, by default True</p> <code>True</code> <code>use_atlas_tag</code> <code>bool</code> <p>Use the ATLAS Tag in the plots, by default True</p> <code>True</code> <code>atlas_first_tag</code> <code>str</code> <p>First row of the ATLAS tag (i.e. the first row is \"ATLAS \"), by default \"Simulation Internal\" <code>'Simulation Internal'</code> <code>atlas_second_tag</code> <code>str</code> <p>Second row of the ATLAS tag, by default \"\"</p> <code>None</code> <code>atlas_fontsize</code> <code>float</code> <p>Fontsize of ATLAS label, by default 10</p> <code>None</code> <code>atlas_vertical_offset</code> <code>float</code> <p>Vertical offset of the ATLAS tag, by default 7</p> <code>7</code> <code>atlas_horizontal_offset</code> <code>float</code> <p>Horizontal offset of the ATLAS tag, by default 8</p> <code>8</code> <code>atlas_brand</code> <code>str</code> <p><code>brand</code> argument handed to atlasify. If you want to remove it just use an empty string or None, by default \"ATLAS\"</p> <code>'ATLAS'</code> <code>atlas_tag_outside</code> <code>bool</code> <p><code>outside</code> argument handed to atlasify. Decides if the ATLAS logo is plotted outside of the plot (on top), by default False</p> <code>False</code> <code>atlas_second_tag_distance</code> <code>float</code> <p>Distance between the <code>atlas_first_tag</code> and <code>atlas_second_tag</code> text in units of line spacing, by default 0</p> <code>0</code> <code>plotting_done</code> <code>bool</code> <p>Bool that indicates if plotting is done. Only then <code>atlasify()</code> can be called, by default False</p> <code>False</code>"},{"location":"api/plot_base/#puma.plot_base.PlotObject.__check_figsize","title":"<code>__check_figsize</code>","text":"<p>Check <code>figsize</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shape of <code>figsize</code> is not a tuple or list with length 2</p> Source code in <code>puma/plot_base.py</code> <pre><code>def __check_figsize(self):\n    \"\"\"Check `figsize`.\n\n    Raises\n    ------\n    ValueError\n        If shape of `figsize` is not a tuple or list with length 2\n    \"\"\"\n    if self.figsize is None:\n        return\n    if isinstance(self.figsize, list) and len(self.figsize) == 2:\n        self.figsize = tuple(self.figsize)\n    elif not isinstance(self.figsize, tuple) or len(self.figsize) != 2:\n        raise ValueError(\n            f\"You passed `figsize` as {self.figsize} which is not allowed. \"\n            \"Either a tuple or a list of size 2 is allowed\"\n        )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotObject.__check_yratio","title":"<code>__check_yratio</code>","text":"<p>Check <code>yratio</code>.</p> <p>Parameters:</p> Name Type Description Default <code>yratio</code> <code>list</code> <p>List of min or max limits of ratio plots</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>yratio</code> is not a list and it's length is not equal to number of ratio panels</p> Source code in <code>puma/plot_base.py</code> <pre><code>def __check_yratio(self, yratio):\n    \"\"\"Check `yratio`.\n\n    Parameters\n    ----------\n    yratio : list\n        List of min or max limits of ratio plots\n\n    Raises\n    ------\n    ValueError\n        If `yratio` is not a list and it's length\n        is not equal to number of ratio panels\n    \"\"\"\n    if yratio is None:\n        return\n    if not isinstance(yratio, (list, tuple)) or len(yratio) != self.n_ratio_panels:\n        raise ValueError(\n            f\"You passed `min/max_yratio` as {yratio} which is not allowed. \"\n            f\"Either a tuple or a list of size {self.n_ratio_panels} is allowed\"\n        )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotObject.__post_init__","title":"<code>__post_init__</code>","text":"<p>Check for allowed values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If n_ratio_panels not in [0, 1, 2, 3]</p> Source code in <code>puma/plot_base.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Check for allowed values.\n\n    Raises\n    ------\n    ValueError\n        If n_ratio_panels not in [0, 1, 2, 3]\n    \"\"\"\n    self.__check_figsize()\n    allowed_n_ratio_panels = [0, 1, 2, 3]\n    if self.n_ratio_panels not in allowed_n_ratio_panels:\n        raise ValueError(\n            f\"{self.n_ratio_panels} not allwed value for `n_ratio_panels`. \"\n            f\"Allowed are {allowed_n_ratio_panels}\"\n        )\n    self.__check_yratio(self.ymin_ratio)\n    self.ymin_ratio = (\n        [None] * self.n_ratio_panels if self.ymin_ratio is None else self.ymin_ratio\n    )\n    self.__check_yratio(self.ymax_ratio)\n    self.ymax_ratio = (\n        [None] * self.n_ratio_panels if self.ymax_ratio is None else self.ymax_ratio\n    )\n\n    if self.ylabel_ratio is None:\n        self.ylabel_ratio = [\"Ratio\"] * self.n_ratio_panels\n    if len(self.ylabel_ratio) != self.n_ratio_panels:\n        raise ValueError(\n            f\"You passed `ylabel_ratio` of length {len(self.ylabel_ratio)}, \"\n            f\"but `n_ratio_panels` of {self.n_ratio_panels}. \"\n            f\"These should be equal.\"\n        )\n    if self.leg_fontsize is None:\n        self.leg_fontsize = self.fontsize\n    if self.atlas_fontsize is None:\n        self.atlas_fontsize = self.fontsize\n    if self.apply_atlas_style is False and (\n        self.atlas_first_tag is not None or self.atlas_second_tag is not None\n    ):\n        logger.warning(\n            \"You specified an ATLAS tag, but `apply_atlas_style` is set to false. \"\n            \"Tag will therefore not be shown on plot.\"\n        )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase","title":"<code>puma.plot_base.PlotBase</code>","text":"<p>               Bases: <code>puma.plot_base.PlotObject</code></p> <p>Base class for plotting.</p> <p>Initialise class.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>puma.plot_base.PlotBase(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"Initialise class.\n\n    Parameters\n    ----------\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n    \"\"\"\n    super().__init__(**kwargs)\n    self.axis_top = None\n    self.ratio_axes = []\n    self.axis_leg = None\n    self.fig = None\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.atlasify","title":"<code>atlasify</code>","text":"<p>Apply ATLAS style to all axes using the atlasify package.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>Force ATLAS style also if class variable is False, by default False</p> <code>False</code> Source code in <code>puma/plot_base.py</code> <pre><code>def atlasify(self, force: bool = False):\n    \"\"\"Apply ATLAS style to all axes using the atlasify package.\n\n    Parameters\n    ----------\n    force : bool, optional\n        Force ATLAS style also if class variable is False, by default False\n    \"\"\"\n    if self.plotting_done is False and force is False:\n        logger.warning(\n            \"`atlasify()` has to be called after plotting --&gt; \"\n            \"ATLAS style will not be adapted. If you want to do it anyway, \"\n            \"you can use `force`.\"\n        )\n        return\n\n    if self.apply_atlas_style or force:\n        logger.debug(\"Initialise ATLAS style using atlasify.\")\n        if self.use_atlas_tag is True:\n            atlasify.atlasify(\n                atlas=self.atlas_first_tag,\n                subtext=self.atlas_second_tag,\n                axes=self.axis_top,\n                font_size=self.atlas_fontsize,\n                label_font_size=self.atlas_fontsize,\n                sub_font_size=self.atlas_fontsize,\n                offset=self.atlas_vertical_offset,\n                indent=self.atlas_horizontal_offset,\n                enlarge=1,\n                brand=\"\" if self.atlas_brand is None else self.atlas_brand,\n                outside=self.atlas_tag_outside,\n                subtext_distance=self.atlas_second_tag_distance,\n            )\n        else:\n            atlasify.atlasify(atlas=False, axes=self.axis_top, enlarge=1)\n        for ratio_axis in self.ratio_axes:\n            atlasify.atlasify(atlas=False, axes=ratio_axis, enlarge=1)\n        if self.vertical_split:\n            atlasify.atlasify(atlas=False, axes=self.axis_leg, enlarge=1)\n        if force:\n            if self.apply_atlas_style is False:\n                logger.warning(\n                    \"Initialising ATLAS style even though `apply_atlas_style` is \"\n                    \" set to False.\"\n                )\n            if self.plotting_done is False:\n                logger.warning(\n                    \"Initialising ATLAS style even though `plotting_done` is set to\" \" False.\"\n                )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.close_window","title":"<code>close_window</code>","text":"<p>Properly close the Tkinter window and exit the main loop.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>tkinter.Tk</code> <p>The Tkinter root window instance to be closed.</p> required Source code in <code>puma/plot_base.py</code> <pre><code>def close_window(self, root: tk.Tk):\n    \"\"\"Properly close the Tkinter window and exit the main loop.\n\n    Parameters\n    ----------\n    root : tk.Tk\n        The Tkinter root window instance to be closed.\n    \"\"\"\n    if root is not None:\n        logger.debug(\"Closing plot window.\")\n\n        # Stop the Tkinter main loop and destroy the window\n        root.quit()\n        root.destroy()\n\n        # Explicitly delete the root object (optional but helps with garbage collection)\n        del root\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.draw_vlines","title":"<code>draw_vlines</code>","text":"<p>Drawing working points in plot.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>list</code> <p>List of working points x values to draw</p> required <code>labels</code> <code>list</code> <p>List with labels for the vertical lines. Must be the same order as the xs. If None, the xvalues * 100 will be used as labels. By default None</p> <code>None</code> <code>ys</code> <code>list</code> <p>List with the y height of the vertical lines in percent of the upper plot (0 is bottom, 1 is top). Must be the same order as the xs and the labels. By default None</p> <code>None</code> <code>same_height</code> <code>bool</code> <p>Working point lines on same height, by default False</p> <code>False</code> <code>colour</code> <code>str</code> <p>Colour of the vertical line, by default \"#000000\" (black)</p> <code>'#000000'</code> <code>linestyle</code> <code>str</code> <p>Linestyle of the vertical line, by default \"dashed\"</p> <code>'dashed'</code> <code>fontsize</code> <code>int</code> <p>Fontsize of the vertical line text. By default 10.</p> <code>10</code> Source code in <code>puma/plot_base.py</code> <pre><code>def draw_vlines(\n    self,\n    xs: list,\n    labels: list | None = None,\n    ys: list | None = None,\n    same_height: bool = False,\n    colour: str = \"#000000\",\n    linestyle: str = \"dashed\",\n    fontsize: int = 10,\n):\n    \"\"\"Drawing working points in plot.\n\n    Parameters\n    ----------\n    xs : list\n        List of working points x values to draw\n    labels : list, optional\n        List with labels for the vertical lines. Must be the same\n        order as the xs. If None, the xvalues * 100 will be\n        used as labels. By default None\n    ys : list, optional\n        List with the y height of the vertical lines in percent of the\n        upper plot (0 is bottom, 1 is top). Must be the same\n        order as the xs and the labels. By default None\n    same_height : bool, optional\n        Working point lines on same height, by default False\n    colour : str, optional\n        Colour of the vertical line, by default \"#000000\" (black)\n    linestyle : str, optional\n        Linestyle of the vertical line, by default \"dashed\"\n    fontsize : int, optional\n        Fontsize of the vertical line text. By default 10.\n    \"\"\"\n    for i, vline_x in enumerate(xs):\n        # Set y-point of the WP lines/text\n        ytext = (0.65 if same_height else 0.65 - i * 0.07) if ys is None else ys[i]\n\n        self.axis_top.axvline(\n            x=vline_x,\n            ymax=ytext,\n            color=colour,\n            linestyle=linestyle,\n            linewidth=1.0,\n        )\n\n        # Set the number above the line\n        self.axis_top.text(\n            x=vline_x - 0.005,\n            y=ytext + 0.005,\n            s=labels[i] if labels else None,\n            transform=self.axis_top.get_xaxis_text1_transform(0)[0],\n            fontsize=fontsize,\n        )\n\n        for ratio_axis in self.ratio_axes:\n            ratio_axis.axvline(x=vline_x, color=colour, linestyle=linestyle, linewidth=1.0)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.initialise_figure","title":"<code>initialise_figure</code>","text":"<p>Initialising matplotlib.figure.Figure for different scenarios depending on how many ratio panels are requested.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def initialise_figure(self):\n    \"\"\"\n    Initialising matplotlib.figure.Figure for different scenarios depending on how\n    many ratio panels are requested.\n    \"\"\"\n    if self.vertical_split:  # split figure vertically instead of horizonally\n        if self.n_ratio_panels &gt;= 1:\n            logger.warning(\n                \"You set the number of ratio panels to %i but also set the\"\n                \" vertical splitting to True. Therefore no ratiopanels are\"\n                \" created.\",\n                self.n_ratio_panels,\n            )\n        self.fig = Figure(figsize=(6, 4.5) if self.figsize is None else self.figsize)\n        g_spec = gridspec.GridSpec(1, 11, figure=self.fig)\n        self.axis_top = self.fig.add_subplot(g_spec[0, :9])\n        self.axis_leg = self.fig.add_subplot(g_spec[0, 9:])\n\n    else:\n        # you must use increments of 0.1 for the dimensions\n        width = 4.7\n        top_height = 2.7 if self.n_ratio_panels else 3.5\n        ratio_height = 1.0\n        height = top_height + self.n_ratio_panels * ratio_height\n        figsize = (width, height) if self.figsize is None else self.figsize\n        self.fig = Figure(figsize=figsize, constrained_layout=True)\n\n        if self.n_ratio_panels == 0:\n            self.axis_top = self.fig.gca()\n        elif self.n_ratio_panels &gt; 0:\n            g_spec_height = (top_height + ratio_height * self.n_ratio_panels) * 10\n            g_spec = gridspec.GridSpec(int(g_spec_height), 1, figure=self.fig)\n            self.axis_top = self.fig.add_subplot(g_spec[: int(top_height * 10), 0])\n            set_xaxis_ticklabels_invisible(self.axis_top)\n            for i in range(1, self.n_ratio_panels + 1):\n                start = int((top_height + ratio_height * (i - 1)) * 10)\n                stop = int(start + ratio_height * 10)\n                sub_axis = self.fig.add_subplot(g_spec[start:stop, 0], sharex=self.axis_top)\n                if i &lt; self.n_ratio_panels:\n                    set_xaxis_ticklabels_invisible(sub_axis)\n                self.ratio_axes.append(sub_axis)\n\n    if self.grid:\n        self.axis_top.grid(lw=0.3)\n        for ratio_axis in self.ratio_axes:\n            ratio_axis.grid(lw=0.3)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.is_running_in_jupyter","title":"<code>is_running_in_jupyter</code>","text":"<p>Detect if running inside a Jupyter notebook.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def is_running_in_jupyter(self):\n    \"\"\"Detect if running inside a Jupyter notebook.\"\"\"\n    try:\n        shell = get_ipython()\n\n        # Running in standard Python interpreter\n        if shell is None:\n            return False\n\n        shell_name = shell.__class__.__name__\n\n        # Jupyter notebook or qtconsole\n        if shell_name == \"ZMQInteractiveShell\":\n            return True\n\n        # Terminal running IPython\n        if shell_name == \"TerminalInteractiveShell\":\n            return False\n\n    # Probably standard Python interpreter\n    except (NameError, ImportError):\n        return False\n\n    else:\n        # Other type (?)\n        return False\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.make_legend","title":"<code>make_legend</code>","text":"<p>Drawing legend on axis.</p> <p>Parameters:</p> Name Type Description Default <code>handles</code> <code> list</code> <p>List of matplotlib.lines.Line2D object returned when plotting</p> required <code>ax_mpl</code> <code>matplotlib.axis.Axes</code> <p><code>matplotlib.axis.Axes</code> object where the legend should be plotted</p> required <code>labels</code> <code>list</code> <p>Plot labels. If None, the labels are extracted from the <code>handles</code>. By default None</p> <code>None</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments which can be passed to matplotlib axis</p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def make_legend(self, handles: list, ax_mpl: axis, labels: list | None = None, **kwargs):\n    \"\"\"Drawing legend on axis.\n\n    Parameters\n    ----------\n    handles :  list\n        List of matplotlib.lines.Line2D object returned when plotting\n    ax_mpl : matplotlib.axis.Axes\n        `matplotlib.axis.Axes` object where the legend should be plotted\n    labels : list, optional\n        Plot labels. If None, the labels are extracted from the `handles`.\n        By default None\n    **kwargs : kwargs\n        Keyword arguments which can be passed to matplotlib axis\n    \"\"\"\n    if labels is None:\n        # remove the handles which have label=None\n        handles = [handle for handle in handles if handle.get_label() is not None]\n    ax_mpl.add_artist(\n        ax_mpl.legend(\n            handles=handles,\n            labels=([handle.get_label() for handle in handles] if labels is None else labels),\n            loc=self.leg_loc,\n            fontsize=self.leg_fontsize,\n            ncol=self.leg_ncol,\n            **kwargs,\n        )\n    )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.make_linestyle_legend","title":"<code>make_linestyle_legend</code>","text":"<p>Create a legend to indicate what different linestyles correspond to.</p> <p>Parameters:</p> Name Type Description Default <code>linestyles</code> <code>list</code> <p>List of the linestyles to draw in the legend</p> required <code>labels</code> <code>list</code> <p>List of the corresponding labels. Has to be in the same order as the linestyles</p> required <code>loc</code> <code>str</code> <p>Location of the legend (matplotlib supported locations), by default None</p> <code>None</code> <code>bbox_to_anchor</code> <code>tuple</code> <p>Allows to specify the precise position of this legend. Either a 2-tuple (x, y) or a 4-tuple (x, y, width, height), by default None</p> <code>None</code> <code>axis_for_legend</code> <code>matplotlib.Axes.axis</code> <p>Axis on which to draw the legend, by default None</p> <code>None</code> Source code in <code>puma/plot_base.py</code> <pre><code>def make_linestyle_legend(\n    self,\n    linestyles: list,\n    labels: list,\n    loc: str | None = None,\n    bbox_to_anchor: tuple | None = None,\n    axis_for_legend=None,\n):\n    \"\"\"Create a legend to indicate what different linestyles correspond to.\n\n    Parameters\n    ----------\n    linestyles : list\n        List of the linestyles to draw in the legend\n    labels : list\n        List of the corresponding labels. Has to be in the same order as the\n        linestyles\n    loc : str, optional\n        Location of the legend (matplotlib supported locations), by default None\n    bbox_to_anchor : tuple, optional\n        Allows to specify the precise position of this legend. Either a 2-tuple\n        (x, y) or a 4-tuple (x, y, width, height), by default None\n    axis_for_legend : matplotlib.Axes.axis, optional\n        Axis on which to draw the legend, by default None\n    \"\"\"\n    if axis_for_legend is None:\n        axis_for_legend = self.axis_top\n\n    lines_list = []\n    for linestyle, label in zip(linestyles, labels):\n        lines_list.append(\n            lines.Line2D(\n                [],\n                [],\n                color=\"k\",\n                label=label,\n                linestyle=linestyle,\n            )\n        )\n\n    linestyle_legend = axis_for_legend.legend(\n        handles=lines_list,\n        labels=[handle.get_label() for handle in lines_list],\n        loc=loc if loc is not None else self.leg_linestyle_loc,\n        fontsize=self.leg_fontsize,\n        bbox_to_anchor=bbox_to_anchor,\n        frameon=False,\n    )\n    axis_for_legend.add_artist(linestyle_legend)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.savefig","title":"<code>savefig</code>","text":"<p>Save plot to disk.</p> <p>Parameters:</p> Name Type Description Default <code>plot_name</code> <code>str</code> <p>File name of the plot</p> required <code>transparent</code> <code>bool</code> <p>Specify if plot background is transparent, by default False</p> <code>None</code> <code>dpi</code> <code>int</code> <p>DPI for plotting, by default 400</p> <code>None</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments passed to <code>matplotlib.figure.Figure.savefig()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def savefig(\n    self,\n    plot_name: str,\n    transparent: bool | None = None,\n    dpi: int | None = None,\n    **kwargs,\n):\n    \"\"\"Save plot to disk.\n\n    Parameters\n    ----------\n    plot_name : str\n        File name of the plot\n    transparent : bool, optional\n        Specify if plot background is transparent, by default False\n    dpi : int, optional\n        DPI for plotting, by default 400\n    **kwargs : kwargs\n        Keyword arguments passed to `matplotlib.figure.Figure.savefig()`\n    \"\"\"\n    logger.debug(\"Saving plot to %s\", plot_name)\n    self.fig.savefig(\n        plot_name,\n        transparent=self.transparent if transparent is None else transparent,\n        dpi=self.dpi if dpi is None else dpi,\n        bbox_inches=\"tight\",\n        pad_inches=0.04,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_log","title":"<code>set_log</code>","text":"<p>Set log scale of the axes.</p> <p>For the y-axis, only the main panel is set. For the x-axes also set the ratio panels.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def set_log(self):\n    \"\"\"Set log scale of the axes.\n\n    For the y-axis, only the main panel is set. For the x-axes also set the\n    ratio panels.\n    \"\"\"\n    if self.logx:\n        self.axis_top.set_xscale(\"log\")\n        for ratio_axis in self.ratio_axes:\n            ratio_axis.set_xscale(\"log\")\n\n    if self.logy:\n        self.axis_top.set_yscale(\"log\")\n        ymin, ymax = self.axis_top.get_ylim()\n        self.y_scale = ymin * ((ymax / ymin) ** self.y_scale) / ymax\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_ratio_label","title":"<code>set_ratio_label</code>","text":"<p>Associate the rejection class to a ratio panel.</p> <p>Parameters:</p> Name Type Description Default <code>ratio_panel</code> <code>int</code> <p>Index of the ratio panel to label.</p> required <code>label</code> <code>str</code> <p>y-axis label of the ratio panel.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested ratio panel does not exist.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def set_ratio_label(self, ratio_panel: int, label: str):\n    \"\"\"Associate the rejection class to a ratio panel.\n\n    Parameters\n    ----------\n    ratio_panel : int\n        Index of the ratio panel to label.\n    label : str\n        y-axis label of the ratio panel.\n\n    Raises\n    ------\n    ValueError\n        If the requested ratio panel does not exist.\n    \"\"\"\n    if ratio_panel &gt; self.n_ratio_panels:\n        raise ValueError(f\"Plot has {self.n_ratio_panels} ratio panels, not {ratio_panel}\")\n    self.ylabel_ratio[ratio_panel - 1] = label\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_tick_params","title":"<code>set_tick_params</code>","text":"<p>Set x-axis label.</p> <p>Parameters:</p> Name Type Description Default <code>labelsize</code> <code>int</code> <p>Label size of x- and y- axis ticks, by default None. If None then using global fontsize</p> <code>None</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_xlabel()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_tick_params(self, labelsize: int | None = None, **kwargs):\n    \"\"\"Set x-axis label.\n\n    Parameters\n    ----------\n    labelsize : int, optional\n        Label size of x- and y- axis ticks, by default None.\n        If None then using global fontsize\n    **kwargs : kwargs\n        Keyword arguments passed to `matplotlib.axes.Axes.set_xlabel()`\n    \"\"\"\n    labelsize = self.fontsize if labelsize is None else labelsize\n    self.axis_top.tick_params(axis=\"y\", labelsize=labelsize, **kwargs)\n    if self.n_ratio_panels == 0:\n        self.axis_top.tick_params(axis=\"x\", labelsize=labelsize, **kwargs)\n    for i, ratio_axis in enumerate(self.ratio_axes):\n        ratio_axis.tick_params(axis=\"y\", labelsize=labelsize, **kwargs)\n        if i == self.n_ratio_panels - 1:\n            ratio_axis.tick_params(axis=\"x\", labelsize=labelsize, **kwargs)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_title","title":"<code>set_title</code>","text":"<p>Set title of top panel.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of top panel, if None using the value form the class variables, by default None</p> <code>None</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_title()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_title(self, title: str | None = None, **kwargs):\n    \"\"\"Set title of top panel.\n\n    Parameters\n    ----------\n    title : str, optional\n        Title of top panel, if None using the value form the class variables,\n        by default None\n    **kwargs : kwargs\n        Keyword arguments passed to `matplotlib.axes.Axes.set_title()`\n    \"\"\"\n    self.axis_top.set_title(self.title if title is None else title, **kwargs)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_xlabel","title":"<code>set_xlabel</code>","text":"<p>Set x-axis label.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>x-axis label, by default None</p> <code>None</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_xlabel()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_xlabel(self, label: str | None = None, **kwargs):\n    \"\"\"Set x-axis label.\n\n    Parameters\n    ----------\n    label : str, optional\n        x-axis label, by default None\n    **kwargs : kwargs\n        Keyword arguments passed to `matplotlib.axes.Axes.set_xlabel()`\n    \"\"\"\n    xlabel_args = {\n        \"xlabel\": self.xlabel if label is None else label,\n        \"horizontalalignment\": \"right\",\n        \"x\": 1.0,\n        \"fontsize\": self.label_fontsize,\n    }\n    if self.n_ratio_panels == 0:\n        self.axis_top.set_xlabel(**xlabel_args, **kwargs)\n    if self.n_ratio_panels &gt; 0:\n        self.ratio_axes[-1].set_xlabel(**xlabel_args, **kwargs)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_xlim","title":"<code>set_xlim</code>","text":"<p>Set limits of x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Min of x-axis, by default None</p> <code>None</code> <code>xmax</code> <code>float</code> <p>Max of x-axis, by default None</p> <code>None</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_xlim()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_xlim(self, xmin: float | None = None, xmax: float | None = None, **kwargs):\n    \"\"\"Set limits of x-axis.\n\n    Parameters\n    ----------\n    xmin : float, optional\n        Min of x-axis, by default None\n    xmax : float, optional\n        Max of x-axis, by default None\n    **kwargs : kwargs\n        Keyword arguments passed to `matplotlib.axes.Axes.set_xlim()`\n    \"\"\"\n    self.axis_top.set_xlim(\n        self.xmin if xmin is None else xmin,\n        self.xmax if xmax is None else xmax,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_y_lim","title":"<code>set_y_lim</code>","text":"<p>Set limits of y-axis.</p> Source code in <code>puma/plot_base.py</code> <pre><code>def set_y_lim(self):\n    \"\"\"Set limits of y-axis.\"\"\"\n    ymin, ymax = self.axis_top.get_ylim()\n    self.axis_top.set_ylim(\n        ymin if self.ymin is None else self.ymin,\n        ymin + (ymax - ymin) * self.y_scale if self.ymax is None else self.ymax,\n    )\n\n    for i, ratio_axis in enumerate(self.ratio_axes):\n        if self.ymin_ratio[i] is not None or self.ymax_ratio[i] is not None:\n            ymin, ymax = ratio_axis.get_ylim()\n            ymin = self.ymin_ratio[i] if self.ymin_ratio[i] is not None else ymin\n            ymax = self.ymax_ratio[i] if self.ymax_ratio[i] is not None else ymax\n            ratio_axis.set_ylim(bottom=ymin, top=ymax)\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.set_ylabel","title":"<code>set_ylabel</code>","text":"<p>Set y-axis label.</p> <p>Parameters:</p> Name Type Description Default <code>ax_mpl</code> <code>matplotlib.axes.Axes</code> <p>matplotlib axis object</p> required <code>label</code> <code>str</code> <p>x-axis label, by default None</p> <code>None</code> <code>align</code> <code>str</code> <p>Alignment of y-axis label, by default \"right\"</p> <code>'right'</code> <code>**kwargs</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_ylabel()</code></p> <code>{}</code> <code>kwargs</code> <p>Keyword arguments passed to <code>matplotlib.axes.Axes.set_ylabel()</code></p> <code>{}</code> Source code in <code>puma/plot_base.py</code> <pre><code>def set_ylabel(self, ax_mpl, label: str | None = None, align: str | None = \"right\", **kwargs):\n    \"\"\"Set y-axis label.\n\n    Parameters\n    ----------\n    ax_mpl : matplotlib.axes.Axes\n        matplotlib axis object\n    label : str, optional\n        x-axis label, by default None\n    align : str, optional\n        Alignment of y-axis label, by default \"right\"\n    **kwargs, kwargs\n        Keyword arguments passed to `matplotlib.axes.Axes.set_ylabel()`\n    \"\"\"\n    label_options = {\"fontsize\": self.label_fontsize}\n    if align:\n        label_options[\"horizontalalignment\"] = align\n        if align == \"right\":\n            label_options[\"y\"] = 1\n        elif align == \"left\":\n            label_options[\"y\"] = 0\n\n    ax_mpl.set_ylabel(\n        self.ylabel if label is None else label,\n        **label_options,\n        **kwargs,\n    )\n    self.fig.align_labels()\n</code></pre>"},{"location":"api/plot_base/#puma.plot_base.PlotBase.show","title":"<code>show</code>","text":"<p>Show the plot using tkinter in command line and detect Jupyter to avoid issues.</p> <p>Parameters:</p> Name Type Description Default <code>auto_close_after</code> <code>int | None</code> <p>After how many milliseconds, the window is automatically closed, by default None</p> <code>None</code> Source code in <code>puma/plot_base.py</code> <pre><code>def show(self, auto_close_after: int | None = None):\n    \"\"\"Show the plot using tkinter in command line and detect Jupyter to avoid issues.\n\n    Parameters\n    ----------\n    auto_close_after : int | None, optional\n        After how many milliseconds, the window is automatically closed, by default None\n    \"\"\"\n    if self.is_running_in_jupyter():\n        logger.debug(\"Detected Jupyter Notebook, displaying inline.\")\n        display(self.fig)\n        return\n\n    logger.debug(\"Showing plot using tkinter\")\n\n    # Ensure figure is initialized\n    if self.fig is None:\n        raise ValueError(\"You need to initalize the figure before using show().\")\n\n    # Create the Tkinter root window\n    root = tk.Tk()\n    root.title(\"Plot Display\")\n\n    # Embed the figure into a Tkinter canvas\n    canvas = FigureCanvasTkAgg(self.fig, master=root)\n    canvas_widget = canvas.get_tk_widget()\n    canvas_widget.pack(fill=\"both\", expand=True)\n\n    # Render the figure\n    canvas.draw()\n\n    # If auto_close_after is set, close the window automatically\n    if auto_close_after:\n        logger.debug(f\"Auto-closing window after {auto_close_after} ms\")\n        root.after(auto_close_after, lambda: self.close_window(root))\n\n    # Handle window close event manually\n    root.protocol(\"WM_DELETE_WINDOW\", lambda: self.close_window(root))\n\n    # Start Tkinter event loop\n    root.mainloop()\n</code></pre>"},{"location":"api/roc/","title":"ROC","text":""},{"location":"api/roc/#puma.roc.Roc","title":"<code>puma.roc.Roc</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>Represent a single ROC curve and allows to calculate ratio w.r.t other ROCs.</p> <p>Initialise properties of roc curve object.</p> <p>Parameters:</p> Name Type Description Default <code>sig_eff</code> <code>numpy.array</code> <p>Array of signal efficiencies</p> required <code>bkg_rej</code> <code>numpy.array</code> <p>Array of background rejection</p> required <code>n_test</code> <code>int</code> <p>Number of events used to calculate the background efficiencies, by default None</p> <code>None</code> <code>signal_class</code> <code>str</code> <p>Signal class, e.g. for b-tagging \"bjets\", by default None</p> <code>None</code> <code>rej_class</code> <code>str or ftag.Label</code> <p>Rejection class, e.g. for b-tagging anc charm rejection \"cjets\", by default None</p> <code>None</code> <code>key</code> <code>str</code> <p>Identifier for roc curve e.g. tagger, by default None</p> <code>None</code> <code>ratio_group</code> <code>str</code> <p>Identifies the reference ROC group for ratio calculation, by default None</p> <code>None</code> <code>**kwargs</code> <code>puma.roc.Roc(kwargs)</code> <p>Keyword arguments passed to <code>puma.PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>sig_eff</code> and <code>bkg_rej</code> have a different shape</p> Source code in <code>puma/roc.py</code> <pre><code>def __init__(\n    self,\n    sig_eff: np.ndarray,\n    bkg_rej: np.ndarray,\n    n_test: int | None = None,\n    rej_class: str | Label = None,\n    signal_class: str | None = None,\n    key: str | None = None,\n    ratio_group: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialise properties of roc curve object.\n\n    Parameters\n    ----------\n    sig_eff : np.array\n        Array of signal efficiencies\n    bkg_rej : np.array\n        Array of background rejection\n    n_test : int\n        Number of events used to calculate the background efficiencies,\n        by default None\n    signal_class : str\n        Signal class, e.g. for b-tagging \"bjets\", by default None\n    rej_class : str or Label\n        Rejection class, e.g. for b-tagging anc charm rejection \"cjets\",\n        by default None\n    key : str\n        Identifier for roc curve e.g. tagger, by default None\n    ratio_group : str, optional\n        Identifies the reference ROC group for ratio calculation, by default None\n    **kwargs : kwargs\n        Keyword arguments passed to `puma.PlotLineObject`\n\n    Raises\n    ------\n    ValueError\n        If `sig_eff` and `bkg_rej` have a different shape\n    \"\"\"\n    super().__init__(**kwargs)\n    if len(sig_eff) != len(bkg_rej):\n        raise ValueError(\n            f\"The shape of `sig_eff` ({np.shape(sig_eff)}) and `bkg_rej` \"\n            f\"({np.shape(bkg_rej)}) have to be identical.\"\n        )\n    self.sig_eff = sig_eff\n    self.bkg_rej = bkg_rej\n    self.n_test = None if n_test is None else int(n_test)\n    self.signal_class = signal_class\n    self.rej_class = Flavours[rej_class] if isinstance(rej_class, str) else rej_class\n    self.key = key\n    self.ratio_group = ratio_group if ratio_group else str(rej_class)\n</code></pre>"},{"location":"api/roc/#puma.roc.Roc.non_zero","title":"<code>non_zero</code>  <code>property</code>","text":"<p>Abstraction of <code>non_zero_mask</code>.</p> <p>Returns:</p> Type Description <code>numpy.array</code> <p>Masked signal efficiency</p> <code>numpy.array</code> <p>Masked background rejection</p>"},{"location":"api/roc/#puma.roc.Roc.non_zero_mask","title":"<code>non_zero_mask</code>  <code>property</code>","text":"<p>Masking points where rejection is 0 and no signal efficiency change present.</p> <p>Returns:</p> Type Description <code>numpy.array</code> <p>Masked indices</p>"},{"location":"api/roc/#puma.roc.Roc.binomial_error","title":"<code>binomial_error</code>","text":"<p>Calculate binomial error of roc curve.</p> <p>Parameters:</p> Name Type Description Default <code>norm</code> <code>bool</code> <p>If True calulate relative error, by default False</p> <code>False</code> <code>n_test</code> <code>int</code> <p>Number of events used to calculate the background efficiencies, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>numpy.array</code> <p>Binomial error</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no <code>n_test</code> was provided</p> Source code in <code>puma/roc.py</code> <pre><code>def binomial_error(self, norm: bool = False, n_test: int | None = None) -&gt; np.ndarray:\n    \"\"\"Calculate binomial error of roc curve.\n\n    Parameters\n    ----------\n    norm : bool\n        If True calulate relative error, by default False\n    n_test : int\n        Number of events used to calculate the background efficiencies,\n        by default None\n\n    Returns\n    -------\n    numpy.array\n        Binomial error\n\n    Raises\n    ------\n    ValueError\n        If no `n_test` was provided\n    \"\"\"\n    if n_test is None:\n        n_test = self.n_test\n    if n_test is None:\n        raise ValueError(\"No `n_test` provided, cannot calculate binomial error!\")\n    return rej_err(self.bkg_rej[self.non_zero_mask], n_test, norm=norm)\n</code></pre>"},{"location":"api/roc/#puma.roc.Roc.divide","title":"<code>divide</code>","text":"<p>Calculate ratio between the roc curve and another roc.</p> <p>Parameters:</p> Name Type Description Default <code>roc_comp</code> <code>roc class</code> <p>Second roc curve to calculate ratio with</p> required <code>inverse</code> <code>bool</code> <p>If False the ratio is calculated <code>this_roc / roc_comp</code>, if True the inverse is calculated</p> <code>False</code> <p>Returns:</p> Type Description <code>numpy.array</code> <p>Signal efficiency used for the ratio calculation which is the overlapping interval of the two roc curves</p> <code>numpy.array</code> <p>Ratio</p> <code>numpy.array or None</code> <p>Ratio_err if <code>n_test</code> was provided to class</p> Source code in <code>puma/roc.py</code> <pre><code>def divide(self, roc_comp, inverse: bool = False):\n    \"\"\"Calculate ratio between the roc curve and another roc.\n\n    Parameters\n    ----------\n    roc_comp : roc class\n        Second roc curve to calculate ratio with\n    inverse : bool\n        If False the ratio is calculated `this_roc / roc_comp`,\n        if True the inverse is calculated\n\n    Returns\n    -------\n    np.array\n        Signal efficiency used for the ratio calculation which is the overlapping\n        interval of the two roc curves\n    np.array\n        Ratio\n    np.array or None\n        Ratio_err if `n_test` was provided to class\n    \"\"\"\n    if not np.array_equal(self.sig_eff, roc_comp.sig_eff):\n        raise ValueError(\"Signal efficiencies of the two ROCs do not match.\")\n\n    ratio = self.bkg_rej / roc_comp.bkg_rej\n    if inverse:\n        ratio = 1 / ratio\n\n    ratio_err = self.binomial_error(norm=True) * ratio if self.n_test else None\n    return self.sig_eff, ratio, ratio_err\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot","title":"<code>puma.roc.RocPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>ROC plot class.</p> <p>ROC plot properties.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>True</code> <code>**kwargs</code> <code>puma.roc.RocPlot(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> Source code in <code>puma/roc.py</code> <pre><code>def __init__(self, grid: bool = True, **kwargs) -&gt; None:\n    \"\"\"ROC plot properties.\n\n    Parameters\n    ----------\n    grid : bool, optional\n        Set the grid for the plots.\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n    \"\"\"\n    super().__init__(grid=grid, **kwargs)\n    self.test = \"\"\n    self.rocs = {}\n    self.roc_ratios = {}\n    self.rej_axes = {}\n    self.rej_class_ls = {}\n    self.label_colours = {}\n    self.leg_rej_labels = {}\n    self.reference_roc = None\n    self.initialise_figure()\n    self.fig.get_layout_engine().set(h_pad=0, hspace=0)\n    self.eff_min, self.eff_max = (1, 0)\n    self.default_linestyles = get_good_linestyles()\n    self.legend_flavs = None\n    self.rej_leg_loc = \"ratio\" if kwargs[\"n_ratio_panels\"] &gt; 0 else \"lower left\"\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.add_ratios","title":"<code>add_ratios</code>","text":"<p>Calculating ratios.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If number of reference rocs and ratio panels don't match</p> <code>ValueError</code> <p>If no ratio classes are set</p> Source code in <code>puma/roc.py</code> <pre><code>def add_ratios(self):\n    \"\"\"Calculating ratios.\n\n    Raises\n    ------\n    ValueError\n        If number of reference rocs and ratio panels don't match\n    ValueError\n        If no ratio classes are set\n    \"\"\"\n    if self.reference_roc and len(self.reference_roc) != self.n_ratio_panels:\n        raise ValueError(\n            f\"{len(self.reference_roc)} reference rocs defined but requested \"\n            f\"{self.n_ratio_panels} ratio panels.\"\n        )\n    if len(self.rej_axes) != self.n_ratio_panels:\n        raise ValueError(\"Ratio classes not set, set them first with `set_ratio_class`.\")\n\n    for rej_class, axis in self.rej_axes.items():\n        self.plot_ratios(axis=axis, rej_class=rej_class)\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.add_roc","title":"<code>add_roc</code>","text":"<p>Adding puma.Roc object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>roc_curve</code> <code>puma.Roc</code> <p>ROC curve</p> required <code>key</code> <code>str</code> <p>Unique identifier for roc_curve, by default None</p> <code>None</code> <code>reference</code> <code>bool</code> <p>If roc is used as reference for ratio calculation, by default False</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/roc.py</code> <pre><code>def add_roc(\n    self,\n    roc_curve: object,\n    key: str | None = None,\n    reference: bool = False,\n):\n    \"\"\"Adding puma.Roc object to figure.\n\n    Parameters\n    ----------\n    roc_curve : puma.Roc\n        ROC curve\n    key : str, optional\n        Unique identifier for roc_curve, by default None\n    reference : bool, optional\n        If roc is used as reference for ratio calculation, by default False\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    if key is None:\n        key = len(self.rocs) + 1\n    if key in self.rocs:\n        raise KeyError(f\"Duplicated key {key} already used for roc unique identifier.\")\n\n    self.rocs[key] = roc_curve\n    # set linestyle\n    if roc_curve.rej_class not in self.rej_class_ls:\n        self.rej_class_ls[roc_curve.rej_class] = (\n            self.default_linestyles[len(self.rej_class_ls)]\n            if roc_curve.linestyle is None\n            else roc_curve.linestyle\n        )\n    elif (\n        roc_curve.linestyle != self.rej_class_ls[roc_curve.rej_class]\n        and roc_curve.linestyle is not None\n    ):\n        logger.warning(\n            \"You specified a different linestyle for the same rejection class \"\n            \"%s. Will keep the linestyle defined first.\",\n            roc_curve.rej_class,\n        )\n    if roc_curve.linestyle is None:\n        roc_curve.linestyle = self.rej_class_ls[roc_curve.rej_class]\n\n    # set colours\n    if roc_curve.label not in self.label_colours:\n        self.label_colours[roc_curve.label] = (\n            get_good_colours()[len(self.label_colours)]\n            if roc_curve.colour is None\n            else roc_curve.colour\n        )\n    elif (\n        roc_curve.colour != self.label_colours[roc_curve.label] and roc_curve.colour is not None\n    ):\n        logger.warning(\n            \"You specified a different colour for the same label\"\n            \" %s. This will lead to a mismatch in the line colours\"\n            \" and the legend.\",\n            roc_curve.label,\n        )\n    if roc_curve.colour is None:\n        roc_curve.colour = self.label_colours[roc_curve.label]\n\n    if reference:\n        logger.debug(\"Setting roc %s as reference for %s.\", key, roc_curve.rej_class)\n        self.set_roc_reference(key, roc_curve.rej_class, roc_curve.ratio_group)\n        self.reference_label = roc_curve.label\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.draw","title":"<code>draw</code>","text":"<p>Draw plotting.</p> <p>Parameters:</p> Name Type Description Default <code>labelpad</code> <code>int</code> <p>Spacing in points from the axes bounding box including ticks and tick labels, by default None</p> <code>None</code> Source code in <code>puma/roc.py</code> <pre><code>def draw(\n    self,\n    labelpad: int | None = None,\n):\n    \"\"\"Draw plotting.\n\n    Parameters\n    ----------\n    labelpad : int, optional\n        Spacing in points from the axes bounding box including\n        ticks and tick labels, by default None\n    \"\"\"\n    plt_handles = self.plot_roc()\n    xmin, xmax = self.get_xlim_auto()\n\n    self.set_xlim(\n        xmin if self.xmin is None else self.xmin,\n        xmax if self.xmax is None else self.xmax,\n    )\n    if self.n_ratio_panels &gt; 0:\n        self.add_ratios()\n    self.set_title()\n    self.set_log()\n    self.set_y_lim()\n    self.set_xlabel()\n    self.set_ylabel(self.axis_top)\n\n    # set ylabel for ratio panels\n    if self.n_ratio_panels &gt; 0:\n        self.set_ylabel(\n            list(self.rej_axes.values())[-1],\n            f\"Ratio to {self.reference_label}\",\n            align=\"left\",\n            labelpad=labelpad,\n        )\n\n    if self.n_ratio_panels &lt; 2:\n        self.make_legend(plt_handles, ax_mpl=self.axis_top)\n    else:\n        if not self.leg_rej_labels:\n            for rej_class in self.rej_axes:\n                self.leg_rej_labels[rej_class] = rej_class\n        self.make_split_legend(handles=plt_handles)\n\n    self.plotting_done = True\n    if self.apply_atlas_style is True:\n        self.atlasify()\n        # atlasify can only handle one legend. Therefore, we remove the frame of\n        # the second legend by hand\n        if self.legend_flavs is not None:\n            self.legend_flavs.set_frame_on(False)\n\n    adjust_ylabels(self.fig, self.rej_axes.values())\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.get_xlim_auto","title":"<code>get_xlim_auto</code>","text":"<p>Returns min and max efficiency values.</p> <p>Returns:</p> Type Description <code>float</code> <p>Min and max efficiency values</p> Source code in <code>puma/roc.py</code> <pre><code>def get_xlim_auto(self):\n    \"\"\"Returns min and max efficiency values.\n\n    Returns\n    -------\n    float\n        Min and max efficiency values\n    \"\"\"\n    for elem in self.rocs.values():\n        self.eff_min = min(np.min(elem.sig_eff), self.eff_min)\n        self.eff_max = max(np.max(elem.sig_eff), self.eff_min)\n\n    return self.eff_min, self.eff_max\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.make_split_legend","title":"<code>make_split_legend</code>","text":"<p>Draw legend for the case of 2 ratios, splitting up legend into models and rejection class.</p> <p>Parameters:</p> Name Type Description Default <code>handles</code> <code>list</code> <p>List of Line2D objects to extract info for legend</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If not 2 ratios requested</p> Source code in <code>puma/roc.py</code> <pre><code>def make_split_legend(self, handles):\n    \"\"\"Draw legend for the case of 2 ratios, splitting up legend into models and\n    rejection class.\n\n    Parameters\n    ----------\n    handles : list\n        List of Line2D objects to extract info for legend\n\n    Raises\n    ------\n    ValueError\n        If not 2 ratios requested\n    \"\"\"\n    if self.n_ratio_panels &lt; 2:\n        raise ValueError(\"For a split legend you need 2 ratio panels.\")\n\n    if self.rej_leg_loc == \"ratio\":\n        for rej_class, axis in self.rej_axes.items():\n            legend_line = mpl.lines.Line2D(\n                [],\n                [],\n                color=\"k\",\n                label=self.leg_rej_labels[rej_class],\n                linestyle=self.rej_class_ls[rej_class],\n            )\n            axis.legend(\n                handles=[legend_line],\n                labels=[legend_line.get_label()],\n                loc=\"upper right\",\n                fontsize=self.leg_fontsize,\n            )\n\n    else:\n        line_list_rej = [\n            mpl.lines.Line2D(\n                [],\n                [],\n                color=\"k\",\n                label=self.leg_rej_labels[rej_class],\n                linestyle=self.rej_class_ls[rej_class],\n            )\n            for rej_class in self.rej_axes\n        ]\n\n        self.legend_flavs = self.axis_top.legend(\n            handles=line_list_rej,\n            labels=[handle.get_label() for handle in line_list_rej],\n            loc=self.rej_leg_loc,\n            fontsize=self.leg_fontsize,\n            ncol=self.leg_ncol,\n        )\n\n        # Add the second legend to plot\n        self.axis_top.add_artist(self.legend_flavs)\n\n    # Get the labels for the legends\n    labels_list = []\n    lines_list = []\n\n    for line in handles:\n        if line.get_label() not in labels_list:\n            labels_list.append(line.get_label())\n            lines_list.append(line)\n\n    # Define the legend\n    self.axis_top.legend(\n        handles=lines_list,\n        labels=labels_list,\n        loc=self.leg_loc,\n        fontsize=self.leg_fontsize,\n        ncol=self.leg_ncol,\n    )\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.plot_ratios","title":"<code>plot_ratios</code>","text":"<p>Plotting ratio curves.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>matplotlib.pyplot.axis</code> <p>matplotlib axis object</p> required <code>rej_class</code> <code>str</code> <p>Rejection class</p> required Source code in <code>puma/roc.py</code> <pre><code>def plot_ratios(self, axis: plt.axis, rej_class: str):\n    \"\"\"Plotting ratio curves.\n\n    Parameters\n    ----------\n    axis : plt.axis\n        matplotlib axis object\n    rej_class : str\n        Rejection class\n    \"\"\"\n    for key, elem in self.rocs.items():\n        if elem.rej_class != rej_class:\n            continue\n        sig_eff, ratio, ratio_err = elem.divide(\n            self.rocs[self.reference_roc[rej_class][elem.ratio_group]]\n        )\n\n        self.roc_ratios[key] = (sig_eff, ratio, ratio_err)\n        axis.plot(\n            sig_eff,\n            ratio,\n            color=elem.colour,\n            linestyle=elem.linestyle,\n            linewidth=2.0,\n        )\n        if ratio_err is not None:\n            axis.fill_between(\n                sig_eff,\n                ratio - ratio_err,\n                ratio + ratio_err,\n                color=elem.colour,\n                alpha=0.25,\n                edgecolor=\"none\",\n                zorder=1,\n            )\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.plot_roc","title":"<code>plot_roc</code>","text":"<p>Plotting roc curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments passed to plt.axis.plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/roc.py</code> <pre><code>def plot_roc(self, **kwargs) -&gt; mpl.lines.Line2D:\n    \"\"\"Plotting roc curves.\n\n    Parameters\n    ----------\n    **kwargs: kwargs\n        Keyword arguments passed to plt.axis.plot\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n    \"\"\"\n    plt_handles = []\n    for key, elem in self.rocs.items():\n        plt_handles = plt_handles + self.axis_top.plot(\n            elem.sig_eff[elem.non_zero_mask],\n            elem.bkg_rej[elem.non_zero_mask],\n            linestyle=elem.linestyle,\n            linewidth=2,\n            color=elem.colour,\n            label=elem.label if elem is not None else key,\n            zorder=2,\n            **kwargs,\n        )\n        if elem.n_test is not None:\n            # if uncertainties are available for roc plotting their uncertainty as\n            # a band around the roc itself\n            rej_band_down = (\n                elem.bkg_rej[elem.non_zero_mask] - elem.binomial_error()[elem.non_zero_mask]\n            )\n            rej_band_up = (\n                elem.bkg_rej[elem.non_zero_mask] + elem.binomial_error()[elem.non_zero_mask]\n            )\n            self.axis_top.fill_between(\n                elem.sig_eff[elem.non_zero_mask],\n                rej_band_down,\n                rej_band_up,\n                color=elem.colour,\n                alpha=0.25,\n                edgecolor=\"none\",\n                zorder=2,\n            )\n    return plt_handles\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.set_ratio_class","title":"<code>set_ratio_class</code>","text":"<p>Associate the rejection class to a ratio panel adn set the legend label.</p> <p>Parameters:</p> Name Type Description Default <code>ratio_panel</code> <code>int</code> <p>Ratio panel either 1 or 2</p> required <code>rej_class</code> <code>Labels</code> <p>Rejeciton class associated to that panel</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if requested ratio panels and given ratio_panel do not match.</p> Source code in <code>puma/roc.py</code> <pre><code>def set_ratio_class(self, ratio_panel: int, rej_class: str | Label):\n    \"\"\"Associate the rejection class to a ratio panel adn set the legend label.\n\n    Parameters\n    ----------\n    ratio_panel : int\n        Ratio panel either 1 or 2\n    rej_class : Labels\n        Rejeciton class associated to that panel\n\n    Raises\n    ------\n    ValueError\n        if requested ratio panels and given ratio_panel do not match.\n    \"\"\"\n    rej_class = Flavours[rej_class] if isinstance(rej_class, str) else rej_class\n    self.rej_axes[rej_class] = self.ratio_axes[ratio_panel - 1]\n    label = rej_class.label.replace(\"jets\", \"jet\")\n    self.set_ratio_label(ratio_panel, f\"{label} ratio\")\n    self.leg_rej_labels[rej_class] = rej_class.label\n</code></pre>"},{"location":"api/roc/#puma.roc.RocPlot.set_roc_reference","title":"<code>set_roc_reference</code>","text":"<p>Setting the reference roc curves used in the ratios.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier of roc object</p> required <code>rej_class</code> <code>str</code> <p>Rejection class encoded in roc curve</p> required <code>ratio_group</code> <code>str</code> <p>Ratio group this roc is reference for, by default None</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more rejection classes are set than actual ratio panels available.</p> Source code in <code>puma/roc.py</code> <pre><code>def set_roc_reference(\n    self,\n    key: str,\n    rej_class: Label,\n    ratio_group: str | None = None,\n):\n    \"\"\"Setting the reference roc curves used in the ratios.\n\n    Parameters\n    ----------\n    key : str\n        Unique identifier of roc object\n    rej_class : str\n        Rejection class encoded in roc curve\n    ratio_group : str\n        Ratio group this roc is reference for, by default None\n\n    Raises\n    ------\n    ValueError\n        If more rejection classes are set than actual ratio panels available.\n    \"\"\"\n    if self.reference_roc is None:\n        self.reference_roc = {}\n        self.reference_roc[rej_class] = {ratio_group: key}\n    elif rej_class not in self.reference_roc:\n        if len(self.reference_roc) &gt;= self.n_ratio_panels:\n            raise ValueError(\n                \"You cannot set more rejection classes than available ratio panels.\"\n            )\n        self.reference_roc[rej_class] = {ratio_group: key}\n    else:\n        if self.reference_roc[rej_class].get(ratio_group):\n            logger.warning(\n                \"You specified a second roc curve %s as reference for ratio. \"\n                \"Using it as new reference instead of %s.\",\n                key,\n                self.reference_roc[rej_class][ratio_group],\n            )\n        self.reference_roc[rej_class][ratio_group] = key\n</code></pre>"},{"location":"api/var_vs_var/","title":"Variable vs Variable","text":""},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVar","title":"<code>puma.var_vs_var.VarVsVar</code>","text":"<p>               Bases: <code>puma.plot_base.PlotLineObject</code></p> <p>VarVsVar class storing info about curve and allows to calculate ratio w.r.t other efficiency plots.</p> <p>Initialise properties of VarVsVar curve object.</p> <p>Parameters:</p> Name Type Description Default <code>x_var</code> <code>numpy.ndarray</code> <p>Values for x-axis variable, e.g. bin midpoints for binned data</p> required <code>y_var_mean</code> <code>numpy.ndarray</code> <p>Mean value for y-axis variable</p> required <code>y_var_std</code> <code>numpy.ndarray</code> <p>Std value for y-axis variable</p> required <code>x_var_widths</code> <code>numpy.ndarray</code> <p>Widths for x-axis variable, e.g. bin widths for binned data</p> <code>None</code> <code>key</code> <code>str</code> <p>Identifier for the curve e.g. tagger, by default None</p> <code>None</code> <code>fill</code> <code>bool</code> <p>Defines do we need to fill box around point, by default True</p> <code>True</code> <code>plot_y_std</code> <code>bool</code> <p>Defines do we need to plot y_var_std, by default True</p> <code>True</code> <code>**kwargs</code> <code>puma.var_vs_var.VarVsVar(kwargs)</code> <p>Keyword arguments passed to <code>PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provided options are not compatible with each other</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def __init__(\n    self,\n    x_var: np.ndarray,\n    y_var_mean: np.ndarray,\n    y_var_std: np.ndarray,\n    x_var_widths: np.ndarray = None,\n    key: str | None = None,\n    fill: bool = True,\n    plot_y_std: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialise properties of VarVsVar curve object.\n\n    Parameters\n    ----------\n    x_var : np.ndarray\n        Values for x-axis variable, e.g. bin midpoints for binned data\n    y_var_mean : np.ndarray\n        Mean value for y-axis variable\n    y_var_std : np.ndarray\n        Std value for y-axis variable\n    x_var_widths : np.ndarray, optional\n        Widths for x-axis variable, e.g. bin widths for binned data\n    key : str, optional\n        Identifier for the curve e.g. tagger, by default None\n    fill : bool, optional\n        Defines do we need to fill box around point, by default True\n    plot_y_std : bool, optional\n        Defines do we need to plot y_var_std, by default True\n    **kwargs : kwargs\n        Keyword arguments passed to `PlotLineObject`\n\n    Raises\n    ------\n    ValueError\n        If provided options are not compatible with each other\n    \"\"\"\n    super().__init__(**kwargs)\n    if len(x_var) != len(y_var_mean):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `y_var_mean` \"\n            f\"({len(y_var_mean)}) have to be identical.\"\n        )\n    if len(x_var) != len(y_var_std):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `y_var_std` \"\n            f\"({len(y_var_std)}) have to be identical.\"\n        )\n    if x_var_widths is not None and len(x_var) != len(x_var_widths):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `x_var_widths` \"\n            f\"({len(x_var_widths)}) have to be identical.\"\n        )\n    self.x_var = np.array(x_var)\n    self.x_var_widths = None if x_var_widths is None else np.array(x_var_widths)\n    self.y_var_mean = np.array(y_var_mean)\n    self.y_var_std = np.array(y_var_std)\n\n    self.key = key\n    self.fill = fill\n    self.plot_y_std = plot_y_std\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVar.divide","title":"<code>divide</code>","text":"<p>Calculate ratio between two class objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>VarVsVar class</code> <p>Second VarVsVar object to calculate ratio with</p> required <code>inverse</code> <code>bool</code> <p>If False the ratio is calculated <code>this / other</code>, if True the inverse is calculated</p> <code>False</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Ratio</p> <code>numpy.ndarray</code> <p>Ratio error</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If binning is not identical between 2 objects</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def divide(self, other, inverse: bool = False, method: str = \"divide\"):\n    \"\"\"Calculate ratio between two class objects.\n\n    Parameters\n    ----------\n    other : VarVsVar class\n        Second VarVsVar object to calculate ratio with\n    inverse : bool\n        If False the ratio is calculated `this / other`,\n        if True the inverse is calculated\n\n    Returns\n    -------\n    np.ndarray\n        Ratio\n    np.ndarray\n        Ratio error\n\n    Raises\n    ------\n    ValueError\n        If binning is not identical between 2 objects\n    \"\"\"\n    if not np.array_equal(self.x_var, other.x_var):\n        raise ValueError(\"The x variables of the two given objects do not match.\")\n    nom, nom_err = self.y_var_mean, self.y_var_std\n    denom, denom_err = other.y_var_mean, other.y_var_std\n\n    ratio, ratio_err = hist_ratio(\n        numerator=denom if inverse else nom,\n        denominator=nom if inverse else denom,\n        numerator_unc=denom_err if inverse else nom_err,\n        step=False,\n        method=method,\n    )\n    return (ratio, ratio_err)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot","title":"<code>puma.var_vs_var.VarVsVarPlot</code>","text":"<p>               Bases: <code>puma.plot_base.PlotBase</code></p> <p>var_vs_eff plot class.</p> <p>var_vs_eff plot properties.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>False</code> <code>ratio_method</code> <code>str</code> <p>Method for ratio calculations. Accepted values: \"divide\", \"root_square_diff\".</p> <code>'divide'</code> <code>**kwargs</code> <code>puma.var_vs_var.VarVsVarPlot(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If incompatible mode given or more than 1 ratio panel requested</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def __init__(self, grid: bool = False, ratio_method: str = \"divide\", **kwargs) -&gt; None:\n    \"\"\"var_vs_eff plot properties.\n\n    Parameters\n    ----------\n    grid : bool, optional\n        Set the grid for the plots.\n    ratio_method:\n        Method for ratio calculations. Accepted values: \"divide\", \"root_square_diff\".\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n\n    Raises\n    ------\n    ValueError\n        If incompatible mode given or more than 1 ratio panel requested\n    \"\"\"\n    super().__init__(grid=grid, **kwargs)\n\n    self.plot_objects = {}\n    self.add_order = []\n    self.ratios_objects = {}\n    self.reference_object = None\n    self.x_var_min = np.inf\n    self.x_var_max = -np.inf\n    self.inverse_cut = False\n    if self.n_ratio_panels &gt; 1:\n        raise ValueError(\"Not more than one ratio panel supported.\")\n    self.ratio_method = ratio_method\n    self.initialise_figure()\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.add","title":"<code>add</code>","text":"<p>Adding VarVsVar object to figure.</p> <p>Parameters:</p> Name Type Description Default <code>curve</code> <code>VarVsVar class</code> <p>VarVsVar curve</p> required <code>key</code> <code>str</code> <p>Unique identifier for VarVsVar curve, by default None</p> <code>None</code> <code>reference</code> <code>bool</code> <p>If VarVsVar is used as reference for ratio calculation, by default False</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If unique identifier key is used twice</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def add(self, curve: VarVsVar, key: str | None = None, reference: bool = False):\n    \"\"\"Adding VarVsVar object to figure.\n\n    Parameters\n    ----------\n    curve : VarVsVar class\n        VarVsVar curve\n    key : str, optional\n        Unique identifier for VarVsVar curve, by default None\n    reference : bool, optional\n        If VarVsVar is used as reference for ratio calculation, by default False\n\n    Raises\n    ------\n    KeyError\n        If unique identifier key is used twice\n    \"\"\"\n    if key is None:\n        key = len(self.plot_objects) + 1\n    if key in self.plot_objects:\n        raise KeyError(f\"Duplicated key {key} already used for unique identifier.\")\n\n    self.plot_objects[key] = curve\n    self.add_order.append(key)\n    # set linestyle\n    if curve.linestyle is None:\n        curve.linestyle = \"-\"\n    # set colours\n    if curve.colour is None:\n        curve.colour = get_good_colours()[len(self.plot_objects) - 1]\n    # set alpha\n    if curve.alpha is None:\n        curve.alpha = 0.8\n    # set linewidth\n    if curve.linewidth is None:\n        curve.linewidth = 1.6\n\n    if curve.is_marker is True:\n        if curve.marker is None:\n            curve.marker = get_good_markers()[len(self.plot_objects)]\n        # Set markersize\n        if curve.markersize is None:\n            curve.markersize = 8\n        if curve.markeredgewidth is None:\n            curve.markeredgewidth = 2\n\n    # set min and max edges\n    if curve.x_var_widths is not None:\n        left_edge = curve.x_var - curve.x_var_widths / 2\n        right_edge = curve.x_var + curve.x_var_widths / 2\n    else:\n        left_edge = curve.x_var\n        right_edge = curve.x_var\n    self.x_var_min = min(self.x_var_min, np.sort(left_edge)[0])\n    self.x_var_max = max(self.x_var_max, np.sort(right_edge)[-1])\n\n    if reference:\n        logger.debug(\"Setting roc %s as reference.\", key)\n        self.set_reference(key)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.draw","title":"<code>draw</code>","text":"<p>Draw figure.</p> <p>Parameters:</p> Name Type Description Default <code>labelpad</code> <code>int</code> <p>Spacing in points from the axes bounding box including ticks and tick labels, by default \"ratio\"</p> <code>None</code> Source code in <code>puma/var_vs_var.py</code> <pre><code>def draw(\n    self,\n    labelpad: int | None = None,\n):\n    \"\"\"Draw figure.\n\n    Parameters\n    ----------\n    labelpad : int, optional\n        Spacing in points from the axes bounding box including\n        ticks and tick labels, by default \"ratio\"\n    \"\"\"\n    self.set_xlim(\n        self.x_var_min if self.xmin is None else self.xmin,\n        self.x_var_max if self.xmax is None else self.xmax,\n    )\n    plt_handles = self.plot()\n    if self.n_ratio_panels == 1:\n        self.plot_ratios()\n    self.set_title()\n    self.set_log()\n    self.set_y_lim()\n    self.set_xlabel()\n    self.set_tick_params()\n    self.set_ylabel(self.axis_top)\n\n    if self.n_ratio_panels &gt; 0:\n        self.set_ylabel(\n            self.ratio_axes[0],\n            self.ylabel_ratio[0],\n            align=\"center\",\n            labelpad=labelpad,\n        )\n    self.make_legend(plt_handles, ax_mpl=self.axis_top)\n    self.plotting_done = True\n    if self.apply_atlas_style is True:\n        self.atlasify()\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.draw_hline","title":"<code>draw_hline</code>","text":"<p>Draw hline in top plot panel.</p> <p>Parameters:</p> Name Type Description Default <code>y_val</code> <code>float</code> <p>y value of the horizontal line</p> required Source code in <code>puma/var_vs_var.py</code> <pre><code>def draw_hline(self, y_val: float):\n    \"\"\"Draw hline in top plot panel.\n\n    Parameters\n    ----------\n    y_val : float\n        y value of the horizontal line\n    \"\"\"\n    self.axis_top.hlines(\n        y=y_val,\n        xmin=self.x_var_min,\n        xmax=self.x_var_max,\n        colors=\"black\",\n        linestyle=\"dotted\",\n        alpha=0.5,\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments passed to plt.axis.errorbar</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Plotting curves.\n\n    Parameters\n    ----------\n    **kwargs: kwargs\n        Keyword arguments passed to plt.axis.errorbar\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n    \"\"\"\n    logger.debug(\"Plotting curves\")\n    plt_handles = []\n    for key in self.add_order:\n        elem = self.plot_objects[key]\n        error_bar = self.axis_top.errorbar(\n            elem.x_var,\n            elem.y_var_mean,\n            xerr=elem.x_var_widths / 2 if elem.x_var_widths is not None else None,\n            yerr=(elem.y_var_std if elem.plot_y_std else np.zeros_like(elem.x_var)),\n            color=elem.colour,\n            fmt=\"none\",\n            label=elem.label,\n            alpha=elem.alpha,\n            linewidth=elem.linewidth,\n            ms=elem.markersize,\n            **kwargs,\n        )\n        # # set linestyle for errorbar\n        error_bar[-1][0].set_linestyle(elem.linestyle)\n        # Draw markers\n        if elem.is_marker is True:\n            self.axis_top.scatter(\n                x=elem.x_var,\n                y=elem.y_var_mean,\n                marker=elem.marker,\n                s=elem.markersize**2,\n                color=elem.colour,\n            )\n        if elem.x_var_widths is not None and elem.fill:\n            for x_pos, y_pos, width, height in zip(\n                elem.x_var,\n                elem.y_var_mean,\n                elem.x_var_widths,\n                2 * elem.y_var_std,\n            ):\n                self.axis_top.add_patch(\n                    Rectangle(\n                        xy=(\n                            x_pos - width / 2,\n                            y_pos - height / 2,\n                        ),\n                        width=width,\n                        height=height,\n                        linewidth=0,\n                        color=elem.colour,\n                        alpha=0.3,\n                        zorder=1,\n                    )\n                )\n        plt_handles.append(\n            mpl.lines.Line2D(\n                [],\n                [],\n                color=elem.colour,\n                label=elem.label,\n                linestyle=elem.linestyle,\n                marker=elem.marker,\n                markersize=elem.markersize,\n            )\n        )\n    return plt_handles\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.plot_ratios","title":"<code>plot_ratios</code>","text":"<p>Plotting ratio curves.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no reference curve is defined</p> Source code in <code>puma/var_vs_var.py</code> <pre><code>def plot_ratios(self):\n    \"\"\"Plotting ratio curves.\n\n    Raises\n    ------\n    ValueError\n        If no reference curve is defined\n    \"\"\"\n    if self.reference_object is None:\n        raise ValueError(\"Please specify a reference curve.\")\n    for key in self.add_order:\n        elem = self.plot_objects[key]\n        (ratio, ratio_err) = elem.divide(\n            self.plot_objects[self.reference_object], method=self.ratio_method\n        )\n        error_bar = self.ratio_axes[0].errorbar(\n            elem.x_var,\n            ratio,\n            xerr=elem.x_var_widths / 2 if elem.x_var_widths is not None else None,\n            yerr=ratio_err if elem.plot_y_std else np.zeros_like(elem.x_var),\n            color=elem.colour,\n            fmt=\"none\",\n            alpha=elem.alpha,\n            linewidth=elem.linewidth,\n            ms=elem.markersize,\n        )\n        # set linestyle for errorbar\n        error_bar[-1][0].set_linestyle(elem.linestyle)\n        # draw markers\n        if elem.is_marker is True:\n            self.ratio_axes[0].scatter(\n                x=elem.x_var,\n                y=ratio,\n                marker=elem.marker,\n                color=elem.colour,\n                s=elem.markersize**2,\n            )\n        if elem.x_var_widths is not None and elem.fill:\n            for x_pos, y_pos, width, height in zip(\n                elem.x_var, ratio, elem.x_var_widths, 2 * ratio_err\n            ):\n                self.ratio_axes[0].add_patch(\n                    Rectangle(\n                        xy=(\n                            x_pos - width / 2,\n                            y_pos - height / 2,\n                        ),\n                        width=width,\n                        height=height,\n                        linewidth=0,\n                        color=elem.colour,\n                        alpha=0.3,\n                        zorder=1,\n                    )\n                )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_var.VarVsVarPlot.set_reference","title":"<code>set_reference</code>","text":"<p>Setting the reference roc curves used in the ratios.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier of roc object</p> required Source code in <code>puma/var_vs_var.py</code> <pre><code>def set_reference(self, key: str):\n    \"\"\"Setting the reference roc curves used in the ratios.\n\n    Parameters\n    ----------\n    key : str\n        Unique identifier of roc object\n    \"\"\"\n    if self.reference_object is None:\n        self.reference_object = key\n    else:\n        logger.warning(\n            \"You specified a second curve %s as reference for ratio. \"\n            \"Using it as new reference instead of %s.\",\n            key,\n            self.reference_object,\n        )\n        self.reference_object = key\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff","title":"<code>puma.var_vs_eff.VarVsEff</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVar</code></p> <p>Class for efficiency vs. variable plot.</p> <p>Initialise properties of roc curve object.</p> <p>Parameters:</p> Name Type Description Default <code>x_var_sig</code> <code>numpy.ndarray</code> <p>Values for x-axis variable for signal</p> required <code>disc_sig</code> <code>numpy.ndarray</code> <p>Discriminant values for signal</p> required <code>x_var_bkg</code> <code>numpy.ndarray</code> <p>Values for x-axis variable for background, by default None</p> <code>None</code> <code>disc_bkg</code> <code>numpy.ndarray</code> <p>Discriminant values for background, by default None</p> <code>None</code> <code>bins</code> <code>int or sequence of scalars</code> <p>If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths, by default 10</p> <code>10</code> <code>working_point</code> <code>float</code> <p>Working point, by default None</p> <code>None</code> <code>disc_cut</code> <code>float or  sequence of floats</code> <p>Cut value for discriminant, if it is a sequence it has to have the same length as number of bins, by default None</p> <code>None</code> <code>flat_per_bin</code> <code>bool</code> <p>If True and no <code>disc_cut</code> is given the signal efficiency is held constant in each bin, by default False</p> <code>False</code> <code>key</code> <code>str</code> <p>Identifier for the curve e.g. tagger, by default None</p> <code>None</code> <code>**kwargs</code> <code>puma.var_vs_eff.VarVsEff(kwargs)</code> <p>Keyword arguments passed to <code>PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provided options are not compatible with each other</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def __init__(\n    self,\n    x_var_sig: np.ndarray,\n    disc_sig: np.ndarray,\n    x_var_bkg: np.ndarray = None,\n    disc_bkg: np.ndarray = None,\n    bins=10,\n    working_point: float | None = None,\n    disc_cut=None,\n    flat_per_bin: bool = False,\n    key: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialise properties of roc curve object.\n\n    Parameters\n    ----------\n    x_var_sig : np.ndarray\n        Values for x-axis variable for signal\n    disc_sig : np.ndarray\n        Discriminant values for signal\n    x_var_bkg : np.ndarray, optional\n        Values for x-axis variable for background, by default None\n    disc_bkg : np.ndarray, optional\n        Discriminant values for background, by default None\n    bins : int or sequence of scalars, optional\n        If bins is an int, it defines the number of equal-width bins in the\n        given range (10, by default). If bins is a sequence, it defines a\n        monotonically increasing array of bin edges, including the\n        rightmost edge, allowing for non-uniform bin widths, by default 10\n    working_point : float, optional\n        Working point, by default None\n    disc_cut : float or  sequence of floats, optional\n        Cut value for discriminant, if it is a sequence it has to have the same\n        length as number of bins, by default None\n    flat_per_bin : bool, optional\n        If True and no `disc_cut` is given the signal efficiency is held constant\n        in each bin, by default False\n    key : str, optional\n        Identifier for the curve e.g. tagger, by default None\n    **kwargs : kwargs\n        Keyword arguments passed to `PlotLineObject`\n\n    Raises\n    ------\n    ValueError\n        If provided options are not compatible with each other\n    \"\"\"\n    if len(x_var_sig) != len(disc_sig):\n        raise ValueError(\n            f\"Length of `x_var_sig` ({len(x_var_sig)}) and `disc_sig` \"\n            f\"({len(disc_sig)}) have to be identical.\"\n        )\n    if x_var_bkg is not None and len(x_var_bkg) != len(disc_bkg):\n        raise ValueError(\n            f\"Length of `x_var_bkg` ({len(x_var_bkg)}) and `disc_bkg` \"\n            f\"({len(disc_bkg)}) have to be identical.\"\n        )\n    # checking that the given options are compatible\n    # could also think about porting it to a class function insted of passing\n    # the arguments to init e.g. `set_method`\n    if working_point is None and disc_cut is None:\n        raise ValueError(\"Either `wp` or `disc_cut` needs to be specified.\")\n    if flat_per_bin:\n        if disc_cut is not None:\n            raise ValueError(\n                \"You cannot specify `disc_cut` when `flat_per_bin` is set to True.\"\n            )\n        if working_point is None:\n            raise ValueError(\n                \"You need to specify a working point `wp`, when `flat_per_bin` is\"\n                \" set to True.\"\n            )\n    self.x_var_sig = np.array(x_var_sig)\n    self.disc_sig = np.array(disc_sig)\n    self.x_var_bkg = None if x_var_bkg is None else np.array(x_var_bkg)\n    self.disc_bkg = None if disc_bkg is None else np.array(disc_bkg)\n    self.working_point = working_point\n    self.disc_cut = disc_cut\n    self.flat_per_bin = flat_per_bin\n    # Binning related variables\n    self.n_bins = None\n    self.bn_edges = None\n    self.x_bin_centres = None\n    self.bin_widths = None\n    self.n_bins = None\n    # Binned distributions\n    self.bin_indices_sig = None\n    self.disc_binned_sig = None\n    self.bin_indices_bkg = None\n    self.disc_binned_bkg = None\n\n    self._set_bin_edges(bins)\n\n    if disc_cut is not None:\n        if working_point is not None:\n            raise ValueError(\"You cannot specify `disc_cut` when providing `wp`.\")\n        if isinstance(disc_cut, (list, np.ndarray)) and self.n_bins != len(disc_cut):\n            raise ValueError(\n                \"`disc_cut` has to be a float or has to have the same length as\"\n                \" number of bins.\"\n            )\n    self._apply_binning()\n    self._get_disc_cuts()\n\n    VarVsVar.__init__(\n        self,\n        x_var=self.x_bin_centres,\n        y_var_mean=np.zeros_like(self.x_bin_centres),\n        y_var_std=np.zeros_like(self.x_bin_centres),\n        x_var_widths=2 * self.bin_widths,\n        key=key,\n        fill=True,\n        plot_y_std=False,\n        **kwargs,\n    )\n    self.inverse_cut = False\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.bkg_eff","title":"<code>bkg_eff</code>  <code>property</code>","text":"<p>Calculate background efficiency per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency</p> <code>numpy.ndarray</code> <p>Efficiency_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.bkg_eff_sig_err","title":"<code>bkg_eff_sig_err</code>  <code>property</code>","text":"<p>Calculate signal efficiency per bin, assuming a flat background per bin. This results in returning the signal efficiency per bin, but the background error per bin.</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.bkg_rej","title":"<code>bkg_rej</code>  <code>property</code>","text":"<p>Calculate background rejection per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Rejection</p> <code>numpy.ndarray</code> <p>Rejection_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.sig_eff","title":"<code>sig_eff</code>  <code>property</code>","text":"<p>Calculate signal efficiency per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency</p> <code>numpy.ndarray</code> <p>Efficiency_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.sig_rej","title":"<code>sig_rej</code>  <code>property</code>","text":"<p>Calculate signal rejection per bin.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Rejection</p> <code>numpy.ndarray</code> <p>Rejection_error</p>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff._apply_binning","title":"<code>_apply_binning</code>","text":"<p>Get binned distributions for the signal and background.</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def _apply_binning(self):\n    \"\"\"Get binned distributions for the signal and background.\"\"\"\n    logger.debug(\"Applying binning.\")\n    self.bin_indices_sig = np.digitize(self.x_var_sig, self.bin_edges)\n    if np.all(self.bin_indices_sig == 0):\n        logger.error(\"All your signal is in the underflow bin. Check your input.\")\n        # retrieve for each bin the part of self.disc_sig corresponding to this bin\n        # and put them in a list\n    self.disc_binned_sig = [\n        self.disc_sig[np.where(self.bin_indices_sig == x)[0]]\n        for x in range(1, len(self.bin_edges))\n    ]\n    if self.x_var_bkg is not None:\n        self.bin_indices_bkg = np.digitize(self.x_var_bkg, self.bin_edges)\n        self.disc_binned_bkg = [\n            self.disc_bkg[np.where(self.bin_indices_bkg == x)[0]]\n            for x in range(1, len(self.bin_edges))\n        ]\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff._get_disc_cuts","title":"<code>_get_disc_cuts</code>","text":"<p>Retrieve cut values on discriminant. If <code>disc_cut</code> is not given, retrieve cut values from the working point.</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def _get_disc_cuts(self):\n    \"\"\"Retrieve cut values on discriminant. If `disc_cut` is not given, retrieve\n    cut values from the working point.\n    \"\"\"\n    logger.debug(\"Calculate discriminant cut.\")\n    if isinstance(self.disc_cut, (float, int)):\n        self.disc_cut = [self.disc_cut] * self.n_bins\n    elif isinstance(self.disc_cut, (list, np.ndarray)):\n        self.disc_cut = self.disc_cut\n    elif self.flat_per_bin:\n        self.disc_cut = [\n            np.percentile(x, (1 - self.working_point) * 100) for x in self.disc_binned_sig\n        ]\n    else:\n        self.disc_cut = [\n            np.percentile(self.disc_sig, (1 - self.working_point) * 100)\n        ] * self.n_bins\n    logger.debug(\"Discriminant cut: %.3f\", self.disc_cut)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff._set_bin_edges","title":"<code>_set_bin_edges</code>","text":"<p>Calculate bin edges, centres and width and save them as class variables.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>int or sequence of scalars</code> <p>If bins is an int, it defines the number of equal-width bins in the given range. If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</p> required Source code in <code>puma/var_vs_eff.py</code> <pre><code>def _set_bin_edges(self, bins):\n    \"\"\"Calculate bin edges, centres and width and save them as class variables.\n\n    Parameters\n    ----------\n    bins : int or sequence of scalars\n        If bins is an int, it defines the number of equal-width bins in the given\n        range. If bins is a sequence, it defines a monotonically increasing array of\n        bin edges, including the rightmost edge, allowing for non-uniform bin\n        widths.\n    \"\"\"\n    logger.debug(\"Calculating binning.\")\n    if isinstance(bins, int):\n        # With this implementation, the data point with x=xmax will be added to the\n        # overflow bin.\n        xmin, xmax = np.amin(self.x_var_sig), np.amax(self.x_var_sig)\n        if self.x_var_bkg is not None:\n            xmin = min(xmin, np.amin(self.x_var_bkg))\n            xmax = max(xmax, np.amax(self.x_var_bkg))\n        # increasing xmax slightly to inlcude largest value due to hehavior of\n        # np.digitize\n        xmax *= 1 + 1e-5\n        self.bin_edges = np.linspace(xmin, xmax, bins + 1)\n    elif isinstance(bins, (list, np.ndarray)):\n        self.bin_edges = np.array(bins)\n    logger.debug(\"Retrieved bin edges %s}\", self.bin_edges)\n    # Get the bins for the histogram\n    self.x_bin_centres = (self.bin_edges[:-1] + self.bin_edges[1:]) / 2.0\n    self.bin_widths = (self.bin_edges[1:] - self.bin_edges[:-1]) / 2.0\n    self.n_bins = self.bin_edges.size - 1\n    logger.debug(\"N bins: %i\", self.n_bins)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.efficiency","title":"<code>efficiency</code>","text":"<p>Calculate efficiency and the associated error.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>numpy.ndarray</code> <p>Array with discriminants</p> required <code>cut</code> <code>float</code> <p>Cut value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Efficiency</p> <code>float</code> <p>Efficiency error</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def efficiency(self, arr: np.ndarray, cut: float):\n    \"\"\"Calculate efficiency and the associated error.\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Array with discriminants\n    cut : float\n        Cut value\n\n    Returns\n    -------\n    float\n        Efficiency\n    float\n        Efficiency error\n    \"\"\"\n    if len(arr) == 0:\n        return 0, 0\n    eff = sum(arr &lt; cut) / len(arr) if self.inverse_cut else sum(arr &gt; cut) / len(arr)\n    eff_error = eff_err(eff, len(arr))\n    return eff, eff_error\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.get","title":"<code>get</code>","text":"<p>Wrapper around rejection and efficiency functions.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Can be \"sig_eff\", \"bkg_eff\", \"sig_rej\", \"bkg_rej\", or \"bkg_eff_sig_err\"</p> required <code>inverse_cut</code> <code>bool</code> <p>Inverts the discriminant cut, which will yield the efficiency or rejection of the jets not passing the working point, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Rejection or efficiency depending on <code>mode</code> value</p> <code>numpy.ndarray</code> <p>Rejection or efficiency error depending on <code>mode</code> value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mode not supported</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def get(self, mode: str, inverse_cut: bool = False):\n    \"\"\"Wrapper around rejection and efficiency functions.\n\n    Parameters\n    ----------\n    mode : str\n        Can be \"sig_eff\", \"bkg_eff\", \"sig_rej\", \"bkg_rej\", or\n        \"bkg_eff_sig_err\"\n    inverse_cut : bool, optional\n        Inverts the discriminant cut, which will yield the efficiency or rejection\n        of the jets not passing the working point, by default False\n\n    Returns\n    -------\n    np.ndarray\n        Rejection or efficiency depending on `mode` value\n    np.ndarray\n        Rejection or efficiency error depending on `mode` value\n\n    Raises\n    ------\n    ValueError\n        If mode not supported\n    \"\"\"\n    self.inverse_cut = inverse_cut\n    if mode == \"sig_eff\":\n        return self.sig_eff\n    if mode == \"bkg_eff\":\n        return self.bkg_eff\n    if mode == \"sig_rej\":\n        return self.sig_rej\n    if mode == \"bkg_rej\":\n        return self.bkg_rej\n    if mode == \"bkg_eff_sig_err\":\n        return self.bkg_eff_sig_err\n    # setting class variable again to False\n    self.inverse_cut = False\n    raise ValueError(\n        f\"The selected mode {mode} is not supported. Use one of the following:\"\n        f\" {VarVsEffPlot.mode_options}.\"\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEff.rejection","title":"<code>rejection</code>","text":"<p>Calculate rejection and the associated error.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>numpy.ndarray</code> <p>Array with discriminants</p> required <code>cut</code> <code>float</code> <p>Cut value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Rejection</p> <code>float</code> <p>Rejection error</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def rejection(self, arr: np.ndarray, cut: float):\n    \"\"\"Calculate rejection and the associated error.\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Array with discriminants\n    cut : float\n        Cut value\n\n    Returns\n    -------\n    float\n        Rejection\n    float\n        Rejection error\n    \"\"\"\n    if self.inverse_cut:\n        rej = save_divide(len(arr), sum(arr &lt; cut), default=np.inf)\n    else:\n        rej = save_divide(len(arr), sum(arr &gt; cut), default=np.inf)\n    if rej == np.inf:\n        logger.warning(\"Your rejection is infinity -&gt; setting it to np.nan.\")\n        return np.nan, np.nan\n    rej_error = rej_err(rej, len(arr))\n    return rej, rej_error\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEffPlot","title":"<code>puma.var_vs_eff.VarVsEffPlot</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVarPlot</code></p> <p>var_vs_eff plot class.</p> <p>var_vs_eff plot properties.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Defines which quantity is plotted, the following options ar available:     sig_eff - Plots signal efficiency vs. variable, with statistical error         on N signal per bin     bkg_eff - Plots background efficiency vs. variable, with statistical         error on N background per bin     sig_rej - Plots signal rejection vs. variable, with statistical error         on N signal per bin     bkg_rej - Plots background rejection vs. variable, with statistical         error on N background per bin     bkg_eff_sig_err - Plots background efficiency vs. variable, with         statistical error on N signal per bin.</p> required <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>False</code> <code>**kwargs</code> <code>puma.var_vs_eff.VarVsEffPlot(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If incompatible mode given or more than 1 ratio panel requested</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def __init__(self, mode, grid: bool = False, **kwargs) -&gt; None:\n    \"\"\"var_vs_eff plot properties.\n\n    Parameters\n    ----------\n    mode : str\n        Defines which quantity is plotted, the following options ar available:\n            sig_eff - Plots signal efficiency vs. variable, with statistical error\n                on N signal per bin\n            bkg_eff - Plots background efficiency vs. variable, with statistical\n                error on N background per bin\n            sig_rej - Plots signal rejection vs. variable, with statistical error\n                on N signal per bin\n            bkg_rej - Plots background rejection vs. variable, with statistical\n                error on N background per bin\n            bkg_eff_sig_err - Plots background efficiency vs. variable, with\n                statistical error on N signal per bin.\n    grid : bool, optional\n        Set the grid for the plots.\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n\n    Raises\n    ------\n    ValueError\n        If incompatible mode given or more than 1 ratio panel requested\n    \"\"\"\n    super().__init__(grid=grid, **kwargs)\n    if mode not in self.mode_options:\n        raise ValueError(\n            f\"The selected mode {mode} is not supported. Use one of the following: \"\n            f\"{self.mode_options}.\"\n        )\n    self.mode = mode\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEffPlot.apply_modified_atlas_second_tag","title":"<code>apply_modified_atlas_second_tag</code>","text":"<p>Modifies the atlas_second_tag to include info on the type of p-eff plot being displayed.</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def apply_modified_atlas_second_tag(\n    self,\n    signal,\n    working_point=None,\n    disc_cut=None,\n    flat_per_bin=False,\n):\n    \"\"\"Modifies the atlas_second_tag to include info on the type of p-eff plot\n    being displayed.\n    \"\"\"\n    if working_point:\n        mid_str = f\"{round(working_point * 100, 3)}% \" + signal.eff_str\n    elif disc_cut:\n        mid_str = rf\"$D_{{{signal.name.rstrip('jets')}}}$ &gt; {disc_cut}\"\n    tag = f\"Flat {mid_str} per bin\" if flat_per_bin else f\"{mid_str}\"\n    if self.atlas_second_tag:\n        self.atlas_second_tag = f\"{self.atlas_second_tag}\\n{tag}\"\n    else:\n        self.atlas_second_tag = tag\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_eff.VarVsEffPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments passed to plt.axis.errorbar</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/var_vs_eff.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Plotting curves.\n\n    Parameters\n    ----------\n    **kwargs: kwargs\n        Keyword arguments passed to plt.axis.errorbar\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n    \"\"\"\n    logger.debug(\"Plotting curves with mode %s\", self.mode)\n    self._setup_curves()\n    return super().plot(**kwargs)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx","title":"<code>puma.var_vs_vtx.VarVsVtx</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVar</code></p> <p>var_vs_vtx class storing info about vertexing performance.</p> <p>Initialise properties of roc curve object.</p> <p>Parameters:</p> Name Type Description Default <code>x_var</code> <code>numpy.ndarray</code> <p>Values for x-axis variable for signal</p> required <code>n_match</code> <code>numpy.ndarray</code> <p>Values for number of correctly identified objects (where truth and reco match)</p> required <code>n_true</code> <code>numpy.ndarray</code> <p>Values for true number of objects</p> required <code>n_reco</code> <code>numpy.ndarray</code> <p>Values for reconstructed number of objects</p> required <code>bins</code> <code>int or sequence of scalars</code> <p>If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths, by default 10</p> <code>10</code> <code>key</code> <code>str</code> <p>Identifier for the curve e.g. tagger, by default None</p> <code>None</code> <code>**kwargs</code> <code>puma.var_vs_vtx.VarVsVtx(kwargs)</code> <p>Keyword arguments passed to <code>PlotLineObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provided options are not compatible with each other</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def __init__(\n    self,\n    x_var: np.ndarray,\n    n_match: np.ndarray,\n    n_true: np.ndarray,\n    n_reco: np.ndarray,\n    bins=10,\n    key: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialise properties of roc curve object.\n\n    Parameters\n    ----------\n    x_var : np.ndarray\n        Values for x-axis variable for signal\n    n_match : np.ndarray\n        Values for number of correctly identified objects (where truth and\n        reco match)\n    n_true : np.ndarray\n        Values for true number of objects\n    n_reco : np.ndarray\n        Values for reconstructed number of objects\n    bins : int or sequence of scalars, optional\n        If bins is an int, it defines the number of equal-width bins in the\n        given range (10, by default). If bins is a sequence, it defines a\n        monotonically increasing array of bin edges, including the\n        rightmost edge, allowing for non-uniform bin widths, by default 10\n    key : str, optional\n        Identifier for the curve e.g. tagger, by default None\n    **kwargs : kwargs\n        Keyword arguments passed to `PlotLineObject`\n\n    Raises\n    ------\n    ValueError\n        If provided options are not compatible with each other\n    \"\"\"\n    if len(x_var) != len(n_match):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `n_match` \"\n            f\"({len(n_match)}) have to be identical.\"\n        )\n    if len(x_var) != len(n_true):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `n_true` \"\n            f\"({len(n_true)}) have to be identical.\"\n        )\n    if len(x_var) != len(n_reco):\n        raise ValueError(\n            f\"Length of `x_var` ({len(x_var)}) and `n_reco` \"\n            f\"({len(n_reco)}) have to be identical.\"\n        )\n\n    self.x_var = np.array(x_var)\n    self.n_match = np.array(n_match)\n    self.n_true = np.array(n_true)\n    self.n_reco = np.array(n_reco)\n    # Binning related variables\n    self.n_bins = None\n    self.bin_edges = None\n    self.x_bin_centres = None\n    self.bin_widths = None\n    # Binned distributions\n    self.bin_indices = None\n    self.metric_binned = None\n\n    self._set_bin_edges(bins)\n    self._apply_binning()\n\n    VarVsVar.__init__(\n        self,\n        x_var=self.x_bin_centres,\n        y_var_mean=np.zeros_like(self.x_bin_centres),\n        y_var_std=np.zeros_like(self.x_bin_centres),\n        x_var_widths=2 * self.bin_widths,\n        key=key,\n        fill=True,\n        plot_y_std=False,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.efficiency","title":"<code>efficiency</code>  <code>property</code>","text":"<p>Calculate vertexing efficiency per bin. Defined as number of reconstructed vertices matched to truth divided by number of total true vertices.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency</p> <code>numpy.ndarray</code> <p>Efficiency error</p>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.fakes","title":"<code>fakes</code>  <code>property</code>","text":"<p>Calculate vertexing fake rate per bin. Defined as total number of events with reconstructed vertices where vertices are not expected.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Fake rate</p> <code>numpy.ndarray</code> <p>Fake rate error</p>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.purity","title":"<code>purity</code>  <code>property</code>","text":"<p>Calculate vertexing purity per bin. Defined as number of reconstructed vertices matched to truth divided by number of total reconstructed vertices.</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Purity</p> <code>numpy.ndarray</code> <p>Purity error</p>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx._apply_binning","title":"<code>_apply_binning</code>","text":"<p>Get binned distributions for number of matches, truth and reco objects.</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def _apply_binning(self):\n    \"\"\"Get binned distributions for number of matches, truth and reco objects.\"\"\"\n    logger.debug(\"Applying binning.\")\n    self.bin_indices = np.digitize(self.x_var, self.bin_edges)\n    self.match_binned = [\n        self.n_match[np.where(self.bin_indices == x)[0]] for x in range(1, len(self.bin_edges))\n    ]\n    self.true_binned = [\n        self.n_true[np.where(self.bin_indices == x)[0]] for x in range(1, len(self.bin_edges))\n    ]\n    self.reco_binned = [\n        self.n_reco[np.where(self.bin_indices == x)[0]] for x in range(1, len(self.bin_edges))\n    ]\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx._set_bin_edges","title":"<code>_set_bin_edges</code>","text":"<p>Calculate bin edges, centres and width and save them as class variables.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>int or sequence of scalars</code> <p>If bins is an int, it defines the number of equal-width bins in the given range. If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</p> required Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def _set_bin_edges(self, bins):\n    \"\"\"Calculate bin edges, centres and width and save them as class variables.\n\n    Parameters\n    ----------\n    bins : int or sequence of scalars\n        If bins is an int, it defines the number of equal-width bins in the given\n        range. If bins is a sequence, it defines a monotonically increasing array of\n        bin edges, including the rightmost edge, allowing for non-uniform bin\n        widths.\n    \"\"\"\n    logger.debug(\"Calculating binning.\")\n    if isinstance(bins, int):\n        # With this implementation, the data point with x=xmax will be added to the\n        # overflow bin.\n        xmin, xmax = np.amin(self.x_var), np.amax(self.x_var)\n        # increasing xmax slightly to inlcude largest value due to hehavior of\n        # np.digitize\n        xmax *= 1 + 1e-5\n        self.bin_edges = np.linspace(xmin, xmax, bins + 1)\n    elif isinstance(bins, (list, np.ndarray)):\n        self.bin_edges = np.array(bins)\n    logger.debug(\"Retrieved bin edges %s}\", self.bin_edges)\n    # Get the bins for the histogram\n    self.x_bin_centres = (self.bin_edges[:-1] + self.bin_edges[1:]) / 2.0\n    self.bin_widths = (self.bin_edges[1:] - self.bin_edges[:-1]) / 2.0\n    self.n_bins = self.bin_edges.size - 1\n    logger.debug(\"N bins: %i\", self.n_bins)\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.get","title":"<code>get</code>","text":"<p>Wrapper around rejection and efficiency functions.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Can be \"efficiency\", \"purity\" or \"fakes\"</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Efficiency, purity or fake rate depending on <code>mode</code> value</p> <code>numpy.ndarray</code> <p>Efficiency, purity or fake rate error depending on <code>mode</code> value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mode not supported</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def get(self, mode: str):\n    \"\"\"Wrapper around rejection and efficiency functions.\n\n    Parameters\n    ----------\n    mode : str\n        Can be \"efficiency\", \"purity\" or \"fakes\"\n\n    Returns\n    -------\n    np.ndarray\n        Efficiency, purity or fake rate depending on `mode` value\n    np.ndarray\n        Efficiency, purity or fake rate error depending on `mode` value\n\n    Raises\n    ------\n    ValueError\n        If mode not supported\n    \"\"\"\n    if mode == \"efficiency\":\n        return self.efficiency\n    if mode == \"purity\":\n        return self.purity\n    if mode == \"fakes\":\n        return self.fakes\n    raise ValueError(\n        f\"The selected mode {mode} is not supported. Use one of the following:\"\n        f\" {VarVsVtxPlot.mode_options}.\"\n    )\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtx.get_performance_ratio","title":"<code>get_performance_ratio</code>","text":"<p>Calculate performance ratio for vertexing task. Either n_matched/n_true (efficiency) or n_matched/n_reco (purity).</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>numpy.ndarray</code> <p>Array with discriminants</p> required <code>cut</code> <code>float</code> <p>Cut value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Performance ratio</p> <code>float</code> <p>Performance ratio error</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def get_performance_ratio(self, num: np.ndarray, denom: np.ndarray):\n    \"\"\"Calculate performance ratio for vertexing task. Either n_matched/n_true\n    (efficiency) or n_matched/n_reco (purity).\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Array with discriminants\n    cut : float\n        Cut value\n\n    Returns\n    -------\n    float\n        Performance ratio\n    float\n        Performance ratio error\n    \"\"\"\n    pm = save_divide(np.sum(num), np.sum(denom), default=np.inf)\n    if pm == np.inf:\n        logger.warning(\"Your vertexing performance ratio is infinity -&gt; setting it to np.nan.\")\n        return np.nan, np.nan\n    if pm == 0:\n        logger.warning(\"Your vertexing performance ratio is zero -&gt; setting error to zero.\")\n        return 0.0, 0.0\n    pm_error = eff_err(pm, len(num))\n    return pm, pm_error\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtxPlot","title":"<code>puma.var_vs_vtx.VarVsVtxPlot</code>","text":"<p>               Bases: <code>puma.var_vs_var.VarVsVarPlot</code></p> <p>var_vs_vtx plot properties.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Defines which quantity is plotted, the following options ar available:     efficiency - Plots efficiency vs. variable for jets where vertices are     expected     purity - Plots purity vs. variable for jets where vertices are expected     fakes - Plots fake rate vs. variable for jets where vertices are not     expected</p> required <code>grid</code> <code>bool</code> <p>Set the grid for the plots.</p> <code>False</code> <code>**kwargs</code> <code>puma.var_vs_vtx.VarVsVtxPlot(kwargs)</code> <p>Keyword arguments from <code>puma.PlotObject</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If incompatible mode given or more than 1 ratio panel requested</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def __init__(self, mode, grid: bool = False, **kwargs) -&gt; None:\n    \"\"\"var_vs_vtx plot properties.\n\n    Parameters\n    ----------\n    mode : str\n        Defines which quantity is plotted, the following options ar available:\n            efficiency - Plots efficiency vs. variable for jets where vertices are\n            expected\n            purity - Plots purity vs. variable for jets where vertices are expected\n            fakes - Plots fake rate vs. variable for jets where vertices are not\n            expected\n    grid : bool, optional\n        Set the grid for the plots.\n    **kwargs : kwargs\n        Keyword arguments from `puma.PlotObject`\n\n    Raises\n    ------\n    ValueError\n        If incompatible mode given or more than 1 ratio panel requested\n    \"\"\"\n    super().__init__(grid=grid, **kwargs)\n    if mode not in self.mode_options:\n        raise ValueError(\n            f\"The selected mode {mode} is not supported. Use one of the following: \"\n            f\"{self.mode_options}.\"\n        )\n    self.mode = mode\n</code></pre>"},{"location":"api/var_vs_var/#puma.var_vs_vtx.VarVsVtxPlot.plot","title":"<code>plot</code>","text":"<p>Plotting curves.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments passed to plt.axis.errorbar</p> <code>{}</code> <p>Returns:</p> Type Description <code>puma.line_plot_2d.Line2D</code> <p>matplotlib Line2D object</p> Source code in <code>puma/var_vs_vtx.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Plotting curves.\n\n    Parameters\n    ----------\n    **kwargs: kwargs\n        Keyword arguments passed to plt.axis.errorbar\n\n    Returns\n    -------\n    Line2D\n        matplotlib Line2D object\n    \"\"\"\n    logger.debug(\"Plotting curves with mode %s\", self.mode)\n    self._setup_curves()\n    return super().plot(**kwargs)\n</code></pre>"},{"location":"dev/development_guidelines/","title":"Good coding practices","text":""},{"location":"dev/development_guidelines/#test-driven-development","title":"Test-Driven Development","text":"<p>The <code>puma</code> framework uses unit tests to reduce the risk for bugs being undetected. If you contribute to <code>puma</code>, please make sure that you add unit tests for the new code.</p>"},{"location":"dev/development_guidelines/#code-style","title":"Code Style","text":"<p>We are using the <code>black</code> python formatter, which also runs in the pipeline to check if your code is properly formatted. Most editors have a quite nice integration of <code>black</code> where you can e.g. set up automatic formatting when you save a file.</p>"},{"location":"dev/development_guidelines/#linters","title":"Linters","text":"<p>In addition to the pure style-component of checking the code with <code>black</code>, we use <code>ruff</code> to check the code for bad coding practices and docstrings. Make sure to run  <code>ruff</code> before you commit your code.</p>"},{"location":"dev/development_guidelines/#pre-commit-hook","title":"Pre-commit hook","text":"<p>To check staged files for style conformity, you can use the <code>pre-commit</code> hook, which then won't allow you to commit your staged changes if <code>ruff</code>  or `black fails. You can set it up by executing the following in the root of the repo:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"dev/docker/","title":"Docker images","text":"<p>The Docker images are built on GitHub and contain the latest version from the <code>main</code> branch.</p> <p>The container registry with all available tags can be found here.</p> <p>On a machine with Docker installed:</p> <pre><code>docker run -it --rm -v $PWD:/puma_container -w /puma_container gitlab-registry.cern.ch/atlas-flavor-tagging-tools/training-images/puma-images/puma:latest bash\n</code></pre> <p>On a machine/cluster with singularity installed:</p> <pre><code>singularity shell -B $PWD docker://gitlab-registry.cern.ch/atlas-flavor-tagging-tools/training-images/puma-images/puma:latest\n</code></pre>"},{"location":"dev/docs_development/","title":"Docs development","text":""},{"location":"dev/docs_development/#adding-a-new-versiontag-to-the-docs","title":"Adding a new version/tag to the docs","text":"<p>To add the docs of a specific release/tag to the deployment on GitHub pages, just add the corresponding version to the file <code>docs/source/_static/switcher.json</code>. The corresponding job in the CI will then automatically build the docs for this release and add it to the deployment.</p> <p></p>"},{"location":"dev/docs_development/#downloading-the-artifact-of-a-dev-version-of-the-docs","title":"Downloading the artifact of a dev version of the docs","text":"<p>When changing something in the <code>puma</code> documentation, you might find yourself in a situation where you want to see if your changes have the intended effect.</p> <p>The docs are only deployed for commits on the <code>main</code> branch. However, the docs are built for every commit, no matter on which branch, and are uploaded as an artifact.</p> <p>This means that you can download the docs as a <code>.zip</code> file and then browser the html files on your machine.</p> <p>If you have an open pull request for your changes, you find the artifact like shown below (click on the button that is marked with the red circle). After downloading, unzip the file and open the <code>artifact/index.html</code> file in your browser. You should then see the docs that you just downloaded.</p> <p> </p>"},{"location":"examples/","title":"Examples","text":"<p>Please find links to the examples in the sidebar on the left.</p> <p>Note that the high-level plotting interface is generally recommended as the fastest and easiest way to make plots.</p>"},{"location":"examples/confusion_matrix/","title":"Confusion Matrix","text":"<p>This function evaluates the (multiclass[^1]) Confusion Matrix (CM) associated to a classifier output predictions. The CM is a metric that measures the misclassification rates between all the classes in the classification task.</p>"},{"location":"examples/confusion_matrix/#mathematical-definition","title":"Mathematical definition","text":"<p>Mathematically, if the classification task has N_c target classes, the CM is an N_c \\times N_c matrix whose entry C_{i,j} is the number of predictions known to be in group i and predicted to be in group j.  The matrix can then be normalized in different ways, obtaining rates of misclassifications instead of raw counts (more on that in normalization).</p>"},{"location":"examples/confusion_matrix/#implementation","title":"Implementation","text":"<p>The function <code>confusion_matrix</code> in <code>puma.utils.confusion_matrix</code> computes the CM from two arrays of target and predicted labels. The basic usage is: <pre><code>targets = np.array([2, 0, 2, 2, 0, 1])\npredictions = np.array([0, 0, 2, 2, 0, 2])\nconfusion_matrix(targets, predictions)\n</code></pre></p> <p>Eventually, samples can be weighted by their relative importance by providing an array of weights w_i \\in [0,1]: <pre><code>targets = np.array([2, 0, 2, 2, 0, 1])\npredictions = np.array([0, 0, 2, 2, 0, 2])\nweights = np.array([1, 0.5, 0.5, 1, 0.2, 1])\nconfusion_matrix(targets, predictions, sample_weights=weights)\n</code></pre></p>"},{"location":"examples/confusion_matrix/#normalization","title":"Normalization","text":"<p>There are four possible normalization choices, which can be selected through the <code>normalize</code> argument of the function: <code>None</code> to use raw counts; <code>\"rownorm\"</code> to normalize across the prediction class, i.e. such that the rows add to one (default); <code>\"colnorm\"</code> to normalize across the target class, i.e. such that the columns add to one; <code>\"all\"</code> to normalize across all examples, i.e. such that all matrix entries add to one. Defaults to <code>\"rownorm\"</code>.</p>"},{"location":"examples/confusion_matrix/#example","title":"Example","text":"<pre><code>from __future__ import annotations\n\nimport numpy as np\n\nfrom puma.utils.confusion_matrix import confusion_matrix\n\n# Sample size\nN = 100\n\n# Number of target classes\nNclass = 3\n\n# Dummy target labels\ntargets = np.random.randint(0, Nclass, size=N)\n# Making sure that there is at least one sample for each class\ntargets = np.append(targets, np.array(list(range(Nclass))))\n\n# Dummy predicted labels\npredictions = np.random.randint(0, Nclass, size=(N + Nclass))\n\n\n# Confusion matrix examples:\n\n# Unweighted confusion matrix, normalized on all entries\nunweighted_cm = confusion_matrix(targets, predictions, normalize=\"all\")\nprint(\"Unweighted, normalized on all entries, CM:\")\nprint(unweighted_cm)\nprint(\" \")\n\n# Unweighted confusion matrix, normalized on true labels\nunweighted_cm = confusion_matrix(targets, predictions, normalize=\"rownorm\")\nprint(\"Unweighted, normalized true labels (rownorm), CM:\")\nprint(unweighted_cm)\nprint(\" \")\n\n# Unweighted confusion matrix, with raw counts (non-normalized)\nunweighted_cm = confusion_matrix(targets, predictions, normalize=None)\nprint(\"Unweighted, non-normalized, CM:\")\nprint(unweighted_cm)\nprint(\" \")\n\n# Weighted Confusion Matrix\n# Dummy sample weights\nsample_weights = np.random.rand(N + Nclass)\n\nweighted_cm = confusion_matrix(targets, predictions, sample_weights=sample_weights)\nprint(\"Weighted CM:\")\nprint(weighted_cm)\n</code></pre> <p>[^1] In a multiclass task, each sample belongs to one and only class (the true label, or target label).</p>"},{"location":"examples/dummy_data/","title":"Dummy Data","text":"<p>To test/demonstrate the <code>puma</code> API, we just want to use dummy data.</p> <p>There are three methods in puma to generate dummy data:</p> <p>The first function returns directly a <code>pandas.DataFrame</code> including the following columns:</p> <ul> <li><code>HadronConeExclTruthLabelID</code></li> <li><code>rnnip_pu</code></li> <li><code>rnnip_pc</code></li> <li><code>rnnip_pb</code></li> <li><code>dips_pu</code></li> <li><code>dips_pc</code></li> <li><code>dips_pb</code></li> </ul> <p>which can be used in the following manner:</p> <pre><code>from puma.utils import get_dummy_2_taggers\n\ndf = get_dummy_2_taggers()\n</code></pre> <p>The second function is <code>get_dummy_multiclass_scores</code> which returns an output array with shape <code>(size, 3)</code>, which is the usual output of our multi-class classifiers like DIPS, and the labels conform with the <code>HadronConeExclTruthLabelID</code> variable.</p> <pre><code>from puma.utils import get_dummy_multiclass_scores\n\noutput, labels = get_dummy_multiclass_scores()\n</code></pre> <p>Finally, the <code>get_dummy_tagger_aux</code> function returns a h5 file with both jet and track collections (needed for aux task plots). These include the following columns (aux task information is generated for both vertexing and track origin classification):</p> <p>jets:</p> <ul> <li><code>HadronConeExclTruthLabelID</code></li> <li><code>GN2_pu</code></li> <li><code>GN2_pc</code></li> <li><code>GN2_pb</code></li> <li><code>pt</code></li> <li><code>eta</code></li> <li><code>n_truth_promptLepton</code></li> </ul> <p>tracks:</p> <ul> <li><code>ftagTruthVertexIndex</code></li> <li><code>GN2_VertexIndex</code></li> <li><code>ftagTruthOriginLabel</code></li> <li><code>GN2_TrackOrigin</code></li> </ul> <p>which can be used in the following manner:</p> <pre><code>from puma.utils import get_dummy_tagger_aux\n\ndf = get_dummy_tagger_aux()\n</code></pre>"},{"location":"examples/fraction_scan/","title":"Fraction Scan Plots","text":"<p>In the following a small example how to plot the rejections for the different fraction value combinations. In this example,  value from numpy arange are used.</p> <p></p> <pre><code>\"\"\"Example of fraction scan plot.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import get_discriminant\n\nfrom puma import Line2D, Line2DPlot\nfrom puma.metrics import calc_eff\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers(size=100_000)\n\nlogger.info(\"caclulate tagger discriminants\")\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\n\nfc_values = np.linspace(0.0, 1.0, 101)\nSIG_EFF = 0.77\n\ndips_scores = df[[\"dips_pu\", \"dips_pc\", \"dips_pb\"]]\n\n\ndef calc_effs(fc_value: float):\n    \"\"\"Tagger efficiency for fixed working point.\n\n    Parameters\n    ----------\n    fc_value : float\n        Value for the charm fraction used in discriminant calculation.\n\n    Returns\n    -------\n    tuple\n        Tuple of shape (, 3) containing (fc_value, ujets_eff, cjets_eff)\n    \"\"\"\n    disc = get_discriminant(dips_scores, \"dips\", signal=\"bjets\", fc=fc_value)\n    ujets_eff = calc_eff(disc[is_b], disc[is_light], SIG_EFF)\n    cjets_eff = calc_eff(disc[is_b], disc[is_c], SIG_EFF)\n\n    return [fc_value, ujets_eff, cjets_eff]\n\n\neff_results = np.array(list(map(calc_effs, fc_values)))\n\n\n# Init example x- and y values of the fraction scan. Theses\n# are the x- and y values for the rejections for different fractions.\n# You can plot 2 rejections against each other. These values can either\n# be arrays, lists, ints or floats but the dtype must be the same and also\n# the number of values inside!\nx_values = eff_results[:, 2]\ny_values = eff_results[:, 1]\n\n# If you want to mark a specific point with a marker, you just need to\n# define the x- and y values again for the marker (This must be floats)\nMARKER_X = eff_results[30, 2]\nMARKER_Y = eff_results[30, 1]\n\n# You can give several plotting options to the plot itself\n\n# Now init a fraction scan plot\nfrac_plot = Line2DPlot()\n\n# Add our x- and y values as a new line\n# The colour and linestyle are optional here\nfrac_plot.add(\n    Line2D(\n        x_values=x_values,\n        y_values=y_values,\n        label=\"Tagger 1\",\n        colour=\"r\",\n        linestyle=\"-\",\n    )\n)\n\n# Add a marker for the just added fraction scan. If you don't\n# set the colour here, the colour of the last added element will be used.\n# marker, markersize and markeredgewidth are optional. The here\n# given values are the default values.\n# The is_marker bool tells the plot that this is a marker and not a line\nfrac_plot.add(\n    Line2D(\n        x_values=MARKER_X,\n        y_values=MARKER_Y,\n        colour=\"r\",\n        marker=\"x\",\n        label=rf\"$f_c={eff_results[30, 0]}$\",\n        markersize=15,\n        markeredgewidth=2,\n    ),\n    is_marker=True,\n)\n\n# Adding labels\nfrac_plot.ylabel = \"Light-flavour jets efficiency\"\nfrac_plot.xlabel = \"$c$-jets efficiency\"\n\n# Draw and save the plot\nfrac_plot.draw()\nfrac_plot.savefig(\"FractionScanPlot_test.png\")\n</code></pre>"},{"location":"examples/histograms/","title":"Histograms","text":"<p>The following examples use the dummy data which is described here</p>"},{"location":"examples/histograms/#b-tagging-discriminant-plot","title":"b-tagging discriminant plot","text":"<pre><code>\"\"\"Produce histogram of discriminant from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import Flavours, get_discriminant\n\nfrom puma import Histogram, HistogramPlot\nfrom puma.utils import get_dummy_2_taggers, get_good_linestyles\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers()\n\n# Calculate discriminant scores for DIPS and RNNIP, and add them to the dataframe\ndisc_dips = get_discriminant(df, \"dips\", \"bjets\", fc=0.018)\ndisc_rnnip = get_discriminant(df, \"rnnip\", \"bjets\", fc=0.018)\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\ntaggers = [\"dips\", \"rnnip\"]\ndiscs = {\"dips\": disc_dips, \"rnnip\": disc_rnnip}\nlinestyles = get_good_linestyles()[:2]\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    n_ratio_panels=1,\n    ylabel=\"Normalised number of jets\",\n    ylabel_ratio=[\"Ratio to DIPS\"],\n    xlabel=\"$b$-jet discriminant\",\n    logy=False,\n    leg_ncol=1,\n    figsize=(5.5, 4.5),\n    bins=np.linspace(-10, 10, 50),\n    y_scale=1.5,\n    ymax_ratio=[1.5],\n    ymin_ratio=[0.5],\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n)\n\n# Add the histograms\nfor tagger, linestyle in zip(taggers, linestyles):\n    plot_histo.add(\n        Histogram(\n            discs[tagger][is_light],\n            # Only specify the label for the case of the \"DIPS\" light-jets, since we\n            # want to hide the legend entry for \"RNNIP\" light-jets as it has the same\n            # linecolour. Instead, we specify a \"linestyle legend\" further down in the\n            # script\n            label=\"Light-flavour jets\" if tagger == \"dips\" else None,\n            colour=Flavours[\"ujets\"].colour,\n            ratio_group=\"ujets\",\n            linestyle=linestyle,\n        ),\n        reference=tagger == \"dips\",\n    )\n    plot_histo.add(\n        Histogram(\n            discs[tagger][is_c],\n            label=\"$c$-jets\" if tagger == \"dips\" else None,\n            colour=Flavours[\"cjets\"].colour,\n            ratio_group=\"cjets\",\n            linestyle=linestyle,\n        ),\n        reference=tagger == \"dips\",\n    )\n    plot_histo.add(\n        Histogram(\n            discs[tagger][is_b],\n            label=\"$b$-jets\" if tagger == \"dips\" else None,\n            colour=Flavours[\"bjets\"].colour,\n            ratio_group=\"bjets\",\n            linestyle=linestyle,\n        ),\n        reference=tagger == \"dips\",\n    )\n\nplot_histo.draw()\n# The lines below create a legend for the linestyles (i.e. solid lines -&gt; DIPS, dashed\n# lines -&gt; RNNIP here). The \"bbox_to_anchor\" argument specifies where to place the\n# linestyle legend\nplot_histo.make_linestyle_legend(\n    linestyles=linestyles, labels=[\"DIPS\", \"RNNIP\"], bbox_to_anchor=(0.55, 1)\n)\nplot_histo.savefig(\"histogram_discriminant.png\", transparent=False)\n</code></pre>"},{"location":"examples/histograms/#flavour-probabilities-plot","title":"Flavour probabilities plot","text":"<pre><code>\"\"\"Example plot script for flavour probability comparison.\"\"\"\n\nfrom __future__ import annotations\n\nfrom puma import Histogram, HistogramPlot\nfrom puma.utils import get_dummy_2_taggers\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers()\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    n_ratio_panels=0,\n    ylabel=\"Normalised number of jets\",\n    xlabel=\"$b$-jets probability\",\n    logy=True,\n    leg_ncol=1,\n    atlas_first_tag=\"Simulation, $\\\\sqrt{s}=13$ TeV\",\n    atlas_second_tag=\"dummy sample, dummy jets\",\n    atlas_brand=None,  # You can deactivate the ATLAS branding (e.g. for a thesis)\n    draw_errors=False,\n    # bins=np.linspace(0, 1, 30),  # you can also force a binning for the plot here\n)\n\n# Add the ttbar histograms\nu_jets = df[df[\"HadronConeExclTruthLabelID\"] == 0]\nc_jets = df[df[\"HadronConeExclTruthLabelID\"] == 4]\nb_jets = df[df[\"HadronConeExclTruthLabelID\"] == 5]\n\n# the \"flavour\" argument will add a \"light-flavour jets\" (or other) prefix to the label\n# + set the colour to the one that is defined in puma.utils.global_config\nplot_histo.add(Histogram(u_jets[\"dips_pb\"], flavour=\"ujets\", linestyle=\"dashed\"))\nplot_histo.add(Histogram(c_jets[\"dips_pb\"], flavour=\"cjets\", linestyle=\"dashdot\"))\nplot_histo.add(Histogram(b_jets[\"dips_pb\"], flavour=\"bjets\"))\n\nplot_histo.draw()\nplot_histo.savefig(\"histogram_bjets_probability.png\", transparent=False)\n</code></pre>"},{"location":"examples/histograms/#more-general-example","title":"More general example","text":"<p>In most cases you probably want to plot histograms with the different flavours like in the examples above. However, the <code>puma</code> API allows to plot any kind of data. As an example, you could also produce a <code>MC</code> vs <code>data</code> plot with the following example code:</p> <p></p> <pre><code>\"\"\"Example of histogram plot that deviates from puma default plots.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\n# Generate two distributions to plot\nN_BKG = int(1e6)\nN_SIG = int(2e4)\nrng = np.random.default_rng(seed=42)\nexpectation = rng.exponential(size=N_BKG)\nmeasurement = np.concatenate((\n    rng.exponential(size=N_BKG),\n    rng.normal(loc=2, scale=0.2, size=N_SIG),\n))\nexpectation_hist = Histogram(expectation, label=\"MC\", histtype=\"stepfilled\", alpha=1)\nmeasurement_hist = Histogram(measurement, label=\"dummy data\")\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    ylabel=\"Number of events\",\n    xlabel=\"Invariant mass $m$ [a.u.]\",\n    logy=False,\n    # bins=np.linspace(0, 5, 60),  # you can force a binning for the plot here\n    bins=50,  # you can also define an integer number for the number of bins\n    bins_range=(1.1, 4),  # only considered if bins is an integer\n    norm=False,\n    atlas_first_tag=\"Simulation Internal\",\n    atlas_second_tag=\"Example for more general plot\",\n    figsize=(6, 5),\n    n_ratio_panels=1,\n)\n\n# Add histograms and plot\nplot_histo.add(expectation_hist, reference=True)\nplot_histo.add(measurement_hist)\nplot_histo.draw()\n\nplot_histo.savefig(\"histogram_basic_example.png\", transparent=False)\n</code></pre>"},{"location":"examples/histograms/#weighted-histograms","title":"Weighted histograms","text":"<p><code>puma</code> also supports weighted histograms by specifying the optional argument <code>weights</code>. An example is given below:</p> <p></p> <pre><code>\"\"\"Example script for plotting weighted histograms.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\nrng = np.random.default_rng(seed=42)\n# we define two gaussian distributions - one located at 0, one at 3\nvalues = np.hstack((rng.normal(size=10_000), rng.normal(loc=3, size=10_000)))\n# for the weighted histogram we weight entries of the right peak by a factor of 2\nweights = np.hstack((np.ones(10_000), 2 * np.ones(10_000)))\n\nhist_plot = HistogramPlot(n_ratio_panels=1, norm=False)\n# add the unweighted histogram\nhist_plot.add(\n    Histogram(values, label=\"Without weights\"),\n    reference=True,\n)\n# add the weighted histogram\nhist_plot.add(\n    Histogram(\n        values,\n        weights=weights,\n        label=\"Weight 2 for right peak\",\n    )\n)\nhist_plot.draw()\nhist_plot.savefig(\"histogram_weighted.png\")\n</code></pre>"},{"location":"examples/histograms/#underflowoverflow-bins","title":"Underflow/overflow bins","text":"<p>Underflow and overflow bins are enabled by default, but can be deactivated using the <code>underoverflow</code> attribute of <code>puma.HistogramPlot</code>. Below an example of the same Gaussian distribution plotted with and without underflow/overflow bins.</p> <p> </p> <pre><code>\"\"\"Example script that demonstrates under/overflow bins.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\nrng = np.random.default_rng(42)\n\nvals = rng.normal(size=10_000)\n\nplot_without = HistogramPlot(bins_range=(-2, 2), underoverflow=False)\nplot_without.title = \"Without underflow/overflow bins\"\nplot_without.add(Histogram(vals, label=\"Gaussian($\\\\mu=0$, $\\\\sigma=1$)\"))\nplot_without.draw()\nplot_without.savefig(\"hist_without_underoverflow.png\")\n\nplot_with = HistogramPlot(bins_range=(-2, 2))\nplot_with.title = \"With underflow/overflow bins\"\nplot_with.add(Histogram(vals, label=\"Gaussian($\\\\mu=0$, $\\\\sigma=1$)\"))\nplot_with.draw()\nplot_with.savefig(\"hist_with_underoverflow.png\")\n</code></pre>"},{"location":"examples/histograms/#datamc-histograms","title":"Data/MC histograms","text":"<p>To visualize the agreement of the Monte-Carlo with data, <code>puma</code> is also able to produce so-called Data/MC histograms. They show the data as a dot histogram while the MC is still a stacked histogram. An example of this plot can be seen here:</p> <p></p> <p>The code to create this example can be found in the <code>examples</code> folder in the <code>plot_data_mc.py</code>. Similar to the rest of the <code>Puma.HistogramPlot</code> examples shown here, a lot of more optional argument can be passed.</p> <pre><code>\"\"\"Example script that demonstrates Data/MC plots.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Histogram, HistogramPlot\n\n# Generate two MC contributions and data\nrng = np.random.default_rng(42)\nmc1 = rng.normal(size=10_000)\nmc2 = rng.normal(size=20_000)\ndata = rng.normal(size=30_000)\n\n# Set up the real plot\ndata_mc_plot = HistogramPlot(\n    bins_range=[-2, 2],\n    n_ratio_panels=1,\n    stacked=True,\n    norm=False,\n)\n\n# Set the plot title\ndata_mc_plot.title = \"Test Data/MC Plot\"\n\n# Add the different MC contributions to the plot\ndata_mc_plot.add(Histogram(mc1, label=\"MC Process 1\"))\ndata_mc_plot.add(Histogram(mc2, label=\"MC Process 2\"))\n\n# Add the data\ndata_mc_plot.add(Histogram(data, label=\"Data\", is_data=True, colour=\"k\"))\n\n# Draw the plot\ndata_mc_plot.draw()\n\n# Add the bin width to the y-axis label\ndata_mc_plot.add_bin_width_to_ylabel()\ndata_mc_plot.savefig(\"data_mc_example.png\")\n</code></pre>"},{"location":"examples/int_eff/","title":"Integrated efficiency plot","text":"<p>In the following a small example how to plot a integrated efficiency plot with the <code>puma</code> API.</p> <p>Then we can start the actual plotting part:</p> <p></p> <pre><code>\"\"\"Produce Integrated Efficiency curves from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nfrom ftag import get_discriminant\n\nfrom puma import IntegratedEfficiency, IntegratedEfficiencyPlot\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers()\n\nlogger.info(\"caclulate tagger discriminants\")\ndiscs_rnnip = get_discriminant(df, \"rnnip\", signal=\"bjets\", fc=0.018)\ndiscs_dips = get_discriminant(df, \"dips\", signal=\"bjets\", fc=0.018)\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\nn_jets_light = sum(is_light)\nn_jets_c = sum(is_c)\n\nlogger.info(\"Calculate signal and background discriminant values.\")\nrnnip = {\n    \"sig_disc\": discs_rnnip[is_b],\n    \"bkg_disc_b\": discs_rnnip[is_b],\n    \"bkg_disc_c\": discs_rnnip[is_c],\n    \"bkg_disc_l\": discs_rnnip[is_light],\n}\ndips = {\n    \"sig_disc\": discs_dips[is_b],\n    \"bkg_disc_b\": discs_dips[is_b],\n    \"bkg_disc_c\": discs_dips[is_c],\n    \"bkg_disc_l\": discs_dips[is_light],\n}\n\n# here the plotting of the Integrated Efficiency curves starts\nlogger.info(\"Plotting IntegratedEfficiency curves.\")\nplot = IntegratedEfficiencyPlot(\n    ylabel=\"Integrated efficiency\",\n    xlabel=\"Discriminant\",\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    figsize=(6.5, 6),\n    y_scale=1.4,\n)\nplot.add(\n    IntegratedEfficiency(rnnip[\"sig_disc\"], rnnip[\"bkg_disc_b\"], flavour=\"bjets\", tagger=\"RRNIP\")\n)\nplot.add(\n    IntegratedEfficiency(rnnip[\"sig_disc\"], rnnip[\"bkg_disc_c\"], flavour=\"cjets\", tagger=\"RRNIP\")\n)\nplot.add(\n    IntegratedEfficiency(rnnip[\"sig_disc\"], rnnip[\"bkg_disc_l\"], flavour=\"ujets\", tagger=\"RRNIP\")\n)\nplot.add(IntegratedEfficiency(dips[\"sig_disc\"], dips[\"bkg_disc_b\"], flavour=\"bjets\", tagger=\"DIPS\"))\nplot.add(IntegratedEfficiency(dips[\"sig_disc\"], dips[\"bkg_disc_c\"], flavour=\"cjets\", tagger=\"DIPS\"))\nplot.add(IntegratedEfficiency(dips[\"sig_disc\"], dips[\"bkg_disc_l\"], flavour=\"ujets\", tagger=\"DIPS\"))\n\nplot.draw()\nplot.savefig(\"integrated_efficiency.png\", transparent=False)\n</code></pre>"},{"location":"examples/line_plots/","title":"Line plots","text":"<p>This is an example on how you can create basic line plots with <code>puma</code>. Of course, this can be easily done with matplotlib directly, but by using <code>puma</code> you get the ATLAS tag and all the functionality <code>puma.PlotObject</code> supports.</p> <p></p> <pre><code>\"\"\"Example for a basic line plot with puma.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nfrom puma import Line2D, Line2DPlot\n\n# This is just some dummy data to make the plot look reasonable\nepochs = np.arange(0, 100)\ntraining_loss = np.exp(-epochs) + np.random.normal(0, 0.01, size=len(epochs)) + 0.8\nvalidation_loss = np.exp(-epochs) + np.random.normal(0, 0.03, size=len(epochs)) + 0.85\n\n# Initialise the plot\nline_plot = Line2DPlot(\n    xlabel=\"Epoch\",\n    ylabel=\"Loss\",\n    atlas_second_tag=\"This is an example of a basic line plot\",\n)\n\n# Add and draw the lines\nline_plot.add(Line2D(epochs, training_loss, label=\"Training loss\"))\nline_plot.add(Line2D(epochs, validation_loss, label=\"Validation loss\"))\nline_plot.draw()\nline_plot.savefig(\"line_plot_example.png\", transparent=False)\n</code></pre>"},{"location":"examples/matrix_plot/","title":"Matrix plot","text":"<p>The class <code>MatshowPlot</code> in <code>puma.matshow</code> is designed to plot matrixes based on <code>matplotlib</code>'s <code>matshow</code>. </p>"},{"location":"examples/matrix_plot/#basic-plot","title":"Basic plot","text":"<p>The class can plot a matrix stored in a <code>np.ndarray</code>:</p> <pre><code>matrix_plotter = MatshowPlot()\nmat = np.random.rand(4, 3)\nmatrix_plotter.draw(mat)\nmatrix_plotter.savefig(\"path/to/save_dir/vanilla_mat.png\")\n</code></pre>"},{"location":"examples/matrix_plot/#plot-customization","title":"Plot customization","text":"<p>Various aspects of the plot appearance can be customized using the class' arguments: - <code>x_ticklabels</code>: Names of the matrix's columns; - <code>x_ticks_rotation</code>: Rotation of the columns' names with respect to the horizontal direction; - <code>y_ticklabels</code>: Names of the matrix's rows; - <code>show_entries</code>: wether to show or not the matrix entries as text over the matrix's pixels (bins); - <code>show_percentage</code>: If <code>True</code>, the entries are formatted as percentages (i.e. numbers in [0,1] are multiplied by 100 and the percentage symbol is appended). - <code>text_color_threshold</code>: threshold on the relative luminance of the background color (i.e. the color of the matrix pixel) after which the overlapped text color switches to black, to allow better readability on lighter background colors. By default is set to 0.408, as per W3C standards; - <code>colormap</code>: <code>pyplot.cm</code> colormap for the plot; - <code>cbar_label</code>: Label of the colorbar;</p>"},{"location":"examples/matrix_plot/#example","title":"Example","text":"<p>Example without any customization:</p> <p></p> <p>Example with some customization:</p> <p></p> <p>Code to obtain previous examples: <pre><code>from __future__ import annotations\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom puma.matshow import MatshowPlot\n\n# seeded PRNG for reproducibility\nprng = np.random.default_rng(seed=0)\n\n# A random matrix\nmat = prng.random(size=(4, 3))\n\n# Declaring the plot class\nmatrix_plotter = MatshowPlot()\nmatrix_plotter.draw(mat)\n# Saving the plot\nmatrix_plotter.savefig(\"vanilla_mat.png\")\n\n# Some possible customizations\n# Matrix's column names\nx_ticks = [\"a\", \"b\", \"c\"]\n# Matrix's rows names\ny_ticks = [\"d\", \"e\", \"f\", \"g\"]\n\n# Declaring the plot class with custom style\nmatrix_plotter_custom = MatshowPlot(\n    x_ticklabels=x_ticks,\n    x_ticks_rotation=45,\n    y_ticklabels=y_ticks,\n    show_entries=True,\n    show_percentage=True,\n    text_color_threshold=0.6,\n    colormap=plt.cm.PiYG,\n    cbar_label=\"Scalar values as percentages\",\n    atlas_tag_outside=True,\n    fontsize=15,\n)\nmatrix_plotter_custom.draw(mat)\n# Saving the plot\nmatrix_plotter_custom.savefig(\"mat_custumized.png\")\n</code></pre></p>"},{"location":"examples/pie_charts/","title":"Pie charts","text":"<p>In the following a small example how to plot a pie chart with the <code>puma</code> API.</p> <p>Then we can start the actual plotting part:</p> <p></p> <p></p> <pre><code>\"\"\"Example plotting script for the puma.PiePlot class.\"\"\"\n\nfrom __future__ import annotations\n\nfrom ftag import Flavours\n\nfrom puma.pie import PiePlot\n\nHadrTruthLabel_fracs = [200_000, 34_000, 150_000, 5_000]\nHadrTruthLabel_labels = [\"Light-flavour jets\", \"$c$-jets\", \"$b$-jets\", \"$\\\\tau$-jets\"]\n\n# Basic example with default values only\nexample_plot_1 = PiePlot(\n    wedge_sizes=HadrTruthLabel_fracs,\n    labels=HadrTruthLabel_labels,\n    figsize=(5.5, 3.5),\n    draw_legend=False,\n)\nexample_plot_1.savefig(\"pie_example_1.png\")\n\n\n# Another example with some styling\n\n# Get the flavour colours from the global config\ncolours = [\n    Flavours[\"ujets\"].colour,\n    Flavours[\"cjets\"].colour,\n    Flavours[\"bjets\"].colour,\n    Flavours[\"taujets\"].colour,\n]\n\nexample_plot_2 = PiePlot(\n    wedge_sizes=HadrTruthLabel_fracs,\n    labels=HadrTruthLabel_labels,\n    draw_legend=False,\n    colours=colours,\n    # have a look at the possible kwargs for matplotlib.pyplot.pie here:\n    # https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.pie.html\n    mpl_pie_kwargs={\n        \"explode\": [0, 0.2, 0, 0.1],\n        \"shadow\": False,\n        \"startangle\": 90,\n        \"textprops\": {\"fontsize\": 10},\n        \"radius\": 1,\n        \"wedgeprops\": {\"width\": 0.4, \"edgecolor\": \"w\"},\n        \"pctdistance\": 0.4,\n    },\n    # kwargs passed to puma.PlotObject\n    atlas_second_tag=\"Dummy flavour fractions\",\n    figsize=(5.5, 3.5),\n    y_scale=1.3,\n)\nexample_plot_2.savefig(\"pie_example_2.png\")\n</code></pre>"},{"location":"examples/precision_recall/","title":"Precision and Recall","text":"<p>The function <code>precision_recall_scores_per_class</code> in <code>puma.utils.precision_recall_scores</code> computes the per-class precision and recall classification metrics, for a multiclass classification task with N_c classes. The metrics are computed by comparing the classifier's predicted labels array with the target labels array. The function returns two arrays where the entry i is the precision or recall score respectively, related to class i. The scores are defined as follows.</p>"},{"location":"examples/precision_recall/#precision","title":"Precision","text":"<p>Fixed a class i between the N_c possible classes, the precision score (also called purity) for that class measures the ability of the classifier not to label as class i a sample belonging to another class. It is defined as:</p> p = \\frac{tp}{tp+fp} <p>where tp is the true positives count and fp is the false positives count in the test set.</p>"},{"location":"examples/precision_recall/#recall","title":"Recall","text":"<p>Fixed a class i between the N_c possible classes, the recall score for that class measures the ability of the classifier to detect every sample belonging to class i in the set. It is defined as:</p> r = \\frac{tp}{tp+fn} <p>where tp is the true positives count and fn is the false negatives count in the test set.</p>"},{"location":"examples/precision_recall/#example","title":"Example","text":"<pre><code>from __future__ import annotations\n\nimport numpy as np\n\nfrom puma.utils.precision_recall_scores import precision_recall_scores_per_class\n\n# Sample size\nN = 100\n\n# Number of target classes\nNclass = 3\n\n# Dummy target labels\ntargets = np.random.randint(0, Nclass, size=N)\n# Making sure that there is at least one sample for each class\ntargets = np.append(targets, np.array(list(range(Nclass))))\n\n# Dummy predicted labels\npredictions = np.random.randint(0, Nclass, size=(N + Nclass))\n\n\n# Unweighted precision and recall\nuw_precision, uw_recall = precision_recall_scores_per_class(targets, predictions)\nprint(\"Unweighted case:\")\nprint(\"Per-class precision:\")\nprint(uw_precision)\nprint(\"Per-class recall:\")\nprint(uw_recall)\nprint(\" \")\n\n# Weighted precision and recall\n# Dummy sample weights\nsample_weights = np.random.rand(N + Nclass)\n\nw_precision, w_recall = precision_recall_scores_per_class(targets, predictions, sample_weights)\nprint(\"Weighted case:\")\nprint(\"Per-class precision:\")\nprint(w_precision)\nprint(\"Per-class recall:\")\nprint(w_recall)\nprint(\" \")\n</code></pre>"},{"location":"examples/rocs/","title":"ROC curves","text":"<p>In the following a small example how to plot a roc curve with the <code>puma</code> API.</p> <p>Then we can start the actual plotting part:</p> <p></p> <pre><code>\"\"\"Produce roc curves from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import get_discriminant\n\nfrom puma import Roc, RocPlot\nfrom puma.metrics import calc_rej\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers(add_pt=True)\n\nlogger.info(\"caclulate tagger discriminants\")\ndiscs_rnnip = get_discriminant(df, \"rnnip\", signal=\"bjets\", fc=0.018)\ndiscs_dips = get_discriminant(df, \"dips\", signal=\"bjets\", fc=0.018)\n\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\nn_jets_light = sum(is_light)\nn_jets_c = sum(is_c)\n\nlogger.info(\"Calculate rejection\")\nrnnip_ujets_rej = calc_rej(discs_rnnip[is_b], discs_rnnip[is_light], sig_eff)\nrnnip_cjets_rej = calc_rej(discs_rnnip[is_b], discs_rnnip[is_c], sig_eff)\ndips_ujets_rej = calc_rej(discs_dips[is_b], discs_dips[is_light], sig_eff)\ndips_cjets_rej = calc_rej(discs_dips[is_b], discs_dips[is_c], sig_eff)\n\n# here the plotting of the roc starts\nlogger.info(\"Plotting ROC curves.\")\nplot_roc = RocPlot(\n    n_ratio_panels=2,\n    ylabel=\"Background rejection\",\n    xlabel=\"$b$-jet efficiency\",\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    figsize=(6.5, 6),\n    y_scale=1.4,\n)\nplot_roc.add_roc(\n    Roc(\n        sig_eff,\n        rnnip_ujets_rej,\n        n_test=n_jets_light,\n        rej_class=\"ujets\",\n        signal_class=\"bjets\",\n        label=\"RNNIP\",\n    ),\n    reference=True,\n)\nplot_roc.add_roc(\n    Roc(\n        sig_eff,\n        dips_ujets_rej,\n        n_test=n_jets_light,\n        rej_class=\"ujets\",\n        signal_class=\"bjets\",\n        label=\"DIPS r22\",\n    ),\n)\nplot_roc.add_roc(\n    Roc(\n        sig_eff,\n        rnnip_cjets_rej,\n        n_test=n_jets_c,\n        rej_class=\"cjets\",\n        signal_class=\"bjets\",\n        label=\"RNNIP\",\n    ),\n    reference=True,\n)\nplot_roc.add_roc(\n    Roc(\n        sig_eff,\n        dips_cjets_rej,\n        n_test=n_jets_c,\n        rej_class=\"cjets\",\n        signal_class=\"bjets\",\n        label=\"DIPS r22\",\n    ),\n)\n# setting which flavour rejection ratio is drawn in which ratio panel\nplot_roc.set_ratio_class(1, \"ujets\")\nplot_roc.set_ratio_class(2, \"cjets\")\n\nplot_roc.draw()\nplot_roc.savefig(\"roc.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/","title":"Umami plotting interface tutorial","text":""},{"location":"examples/tutorial-plotting/#introduction","title":"Introduction","text":"<p>In this tutorial you will learn how to use <code>puma</code>, the Plotting UMami Api. The idea behind <code>puma</code> is to provide a plotting API that is easy to use but at the same time highly configurable. This means that the user has full control over the plot while things like uncertainties, labels, ratio panels can be added easily.</p> <p>You can find the <code>puma</code> documentation here.</p> <p><code>puma</code> is based on <code>matplotlib</code> and helps you to produce most of the types of plots that are commonly used in flavour tagging like the ones shown below:</p> ROC curves Histogram plots Variable vs efficiency <p>In this tutorial you will learn how to:</p> <ol> <li>A small introduction to the different metrics used in flavour tagging.</li> <li>Plot histograms with <code>puma</code>, where you will produce plots of both jet- and track-variables.</li> <li>Plot ROC curves of two taggers, with ratio panels that compare the curves.</li> <li>Plot the efficiency/rejection of a tagger as a function of p_T.</li> <li>Plot the input variables of the files using Umami.</li> </ol> <p>The tutorial is meant to be followed in a self-guided manner. You will be prompted to do certain tasks by telling you what the desired outcome will be, without telling you how to do it. Using the documentation of the training-dataset-dumper, you can find out how to achieve your goal. In case you are stuck, you can click on the \"hint\" toggle box to get a hint. If you tried for more than 10 min at a problem, feel free to toggle also the solution with a worked example.</p>"},{"location":"examples/tutorial-plotting/#setting-up-everything-you-need","title":"Setting Up Everything You Need","text":"<p>For the tutorial, you will need both <code>puma</code> and (for the Task 4) <code>umami</code>. While <code>puma</code> can be easily installed via the command</p> <pre><code>pip install puma-hep\n</code></pre> <p>installing <code>umami</code> is not so easy. Due to this fact, we encourage you to use docker or singularity images from <code>umami</code> (<code>puma</code> is already installed in there). An explanation how to run singularity images (also on lxplus) can be found here. If you have access to the <code>cvmfs</code>, you can easily run this from there without building the container locally again (also explained here).</p> <p>For this tutorial, two <code>.h5</code> files were prepared, one t\\bar{t} and one Z' file. You can download them from the <code>eos</code> directly. The path to the directory where the files are stored is <code>/eos/user/u/umamibot/tutorials/</code>.</p>"},{"location":"examples/tutorial-plotting/#tutorial-tasks","title":"Tutorial tasks","text":"<p>The tasks are divided in several sub-tasks. You don't have to do all of them in case you are more interested in the other tasks. However, the sub-tasks depend on each other, so you should finish a subtask before proceeding to the next one (also the solutions assume that you already have the previous subtasks completed).</p>"},{"location":"examples/tutorial-plotting/#task-0-flavour-tagging-metrics","title":"Task 0: Flavour tagging metrics","text":"<p>To get started with the plotting, we will first have a quick look into different metrics used in flavour tagging to evaluate the performance.</p>"},{"location":"examples/tutorial-plotting/#task-01-generating-dummy-data","title":"Task 0.1: Generating dummy data","text":"<p>The typical output of our ML-based taggers, like DIPS or DL1d, are 3 scores indicating the probabilities of being a light-flavour jet, a c-jet and a b-jet. For example the scores <code>[0.1, 0.3, 0.6]</code> would indicate that we have most probably a b-jet while <code>[0.7, 0.2, 0.1]</code> would indicate a light-flavour jet.</p> <p>Even though we always have MC simulation, it is sometimes useful to have dummy data, for instance if we want to test certain plotting features etc. (and to understand the actual underlying distributions).</p> <p>Now, it is up to you. Generate a dummy multi-class output of a neural network.</p> Hint: Where can I find such a function? <p>You can have a look at the puma documentation and search in the API reference.</p> Hint: Which exact function? <p>the <code>puma.utils.generate</code> module contains the desired functions</p> Solution <pre><code>from puma.utils.generate import get_dummy_multiclass_scores\n\n# Generating 10_000 jets\ndummy_jets, dummy_labels = get_dummy_multiclass_scores()\nprint(dummy_jets)\nprint(dummy_labels)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-02-defining-working-points-likelihood-ratio","title":"Task 0.2: Defining Working points - Likelihood ratio","text":"<p>Since we are not (yet) able to calibrate the entire spectrum of the different multi-class outputs, we need to define so-called working points (or operating points). In the case of ATLAS, we have four different b-tagging working points (WPs) which are defined covering various needs of the physics analyses. The efficiency of a specific flavour j (b, c or light) is defined as</p>  \\varepsilon^j = \\frac{N_\\text{pass}^j(\\mathcal{D}&gt;T_f)}{N_\\text{total}^j},  <p>where N_\\text{pass}^j(\\mathcal{D}&gt;T_f) are the number of jets of flavour j passing the cut T_f on the tagger discriminant \\mathcal{D} and N_\\text{total}^j are all jets of flavour j before the cut.</p> <p>The final output score is calculated from the multi-class output and results for the b-tagging discriminant into the log-likelihood</p>  \\mathcal{D}_\\text{b}(f_c) = \\log \\left(  \\frac{p_b}{f_c\\cdot p_c+(1-f_c)\\cdot p_\\text{l}} \\right),  <p>with p_b, p_c and p_l being the probabilities for the jet to be a b-jet, c-jet or light-flavour jet, respectively. The c-jet fraction f_c allows to tune how much emphasis is given to the c-jet or to the light-flavour performance. While the c-jet rejection increases as a function of f_c, the light-flavour jet rejection decreases. This parameter has to be tuned separately for each tagger and depends on the needs of the physics analyses.</p> <p>The advantage of the multi-class output is that this tuning is possible after the training and the c-jet fraction in the training sample does not have to be adapted. Another advantage of the multi-class output is that one can by changing the log-likelihood to</p>  \\mathcal{D}_\\text{c}(f_b) = \\log \\left(  \\frac{p_c}{f_b\\cdot p_b+(1-f_b)\\cdot p_l} \\right),  <p>perform c-tagging without the need of retraining the tagger. Here f_b is now the b-jet fraction.</p> <p>Define a function which calculates the log-likelihood, when giving it the 3 scores and the f_c value as input.</p> Hint 1 <p>You can either use a python function <code>def</code> or a <code>lambda</code> function</p> Hint 2 <p>In the puma examples you might find something similar.</p> Solution <p>You can find the solution in the histogram example of the puma documentation.</p> <pre><code>import numpy as np\ndef disc_fct(arr: np.ndarray, f_c: float = 0.018) -&gt; np.ndarray:\n    \"\"\"Tagger discriminant\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        array with with shape (, 3)\n    f_c : float, optional\n        f_c value in the discriminant (weight for c-jets rejection)\n\n    Returns\n    -------\n    np.ndarray\n        Array with the discriminant values inside.\n    \"\"\"\n    # you can adapt this for your needs\n    return np.log(arr[2] / (f_c * arr[1] + (1 - f_c) * arr[0]))\n\n\n# you can also use a lambda function\n# fc = 0.018\n# lambda a: np.log(a[2] / (fc * a[1] + (1 - fc) * a[0]))\n</code></pre> <p>Using the <code>dummy data</code> from task 0.1, calculate the log-likelihood with f_c=0.018 and retrieve the working point cut value for 70% b-jet efficiency.</p> Hint: Where to get the labels from? <p>the <code>labels</code> from task 0.1 have the same values as the <code>HadronConeExclTruthLabelID</code> described in the FTAG algo docs.</p> Hint: Which function to use? <p>You can have a look at the <code>percentile</code> function from <code>numpy</code>. Be aware from which site we need to integrate! And the <code>apply_along_axis</code> function to evaluate an entire array.</p> Solution <p><pre><code>import numpy as np\n\nbjets = dummy_labels == 5\nscores = np.apply_along_axis(disc_fct, axis=1, arr=dummy_jets)\ntarget_eff = 0.7\ncutvalue = np.percentile(scores[bjets], 100.0 * (1.0 - target_eff))\nprint(\"cut value for 70% b-jet efficiency:\", cutvalue)\n</code></pre> You can also have a look at the metrics function in puma, where this code is also being used.</p>"},{"location":"examples/tutorial-plotting/#task-03-performance-metrics-efficiency-and-rejection","title":"Task 0.3: Performance metrics - efficiency and rejection","text":"<p>To quantify the performance of a tagger at a given working point, the background rejection is a good measure. The rejection is simply the inverse of the efficiency \\frac{1}{\\varepsilon^j}.</p> <p>Calculate the light-flavour jet and c-jet rejection for the 70% working point from task 0.2.</p> Solution <pre><code>ljets = dummy_labels == 0\ncjets = dummy_labels == 4\n\nljets_eff = ((scores &gt; cutvalue) &amp; ljets).sum() / ljets.sum()\nprint(\"light-flavour jets efficiency:\", ljets_eff)\nprint(\"light-flavour jets rejection:\", 1 / ljets_eff)\n\ncjets_eff = ((scores &gt; cutvalue) &amp; cjets).sum() / cjets.sum()\nprint(\"c-flavour jets efficiency:\", cjets_eff)\nprint(\"c-flavour jets rejection:\", 1 / cjets_eff)\n</code></pre> <p>Alternatively, all this functionality is also provided by <code>puma.metrics</code>. In that case this would simplify to <pre><code>from puma.metrics import calc_rej\nljets = dummy_labels == 0\ncjets = dummy_labels == 4\nrej = calc_rej(scores[bjets], scores[ljets], target_eff=0.7)\nprint(\"light-flavour jets rejection:\", rej)\n</code></pre></p> <p>Starting from these metrics, we can plot for instance:</p> <ul> <li>ROC curves: which show the background rejection as function of the b-jet efficency</li> <li>Efficiency vs p_T: where one fixes a working point and calculates the background rejection in bins of p_T</li> </ul>"},{"location":"examples/tutorial-plotting/#task-1-histogram-plots","title":"Task 1: Histogram plots","text":""},{"location":"examples/tutorial-plotting/#task-11-loading-the-h5-file","title":"Task 1.1: Loading the h5 file","text":"<p>Before starting with the different plotting exercises, you have to load the h5 file that was prepared for this tutorial. The expected outcome of this is that you have access to the jet variables as well as to the track variables. You can put the jet variables in a <code>pandas.DataFrame</code> in case you feel more comfortable with that, but this will not be possible for the tracks, since the <code>tracks_loose</code> dataset in the h5 file has an extra dimension for the tracks (for each jet we store the information of up to 40 tracks).</p> <ol> <li>Write a little python script that loads the jet and track variables.</li> <li>Have a look at how large the dataset is, and what shape the loaded arrays have.</li> </ol> <p>For the following tasks you can re-use the code that loads the h5 file or just extend your python script from this task.</p> Hint: how can I load a h5 file with python? <p>You can find the documentation of <code>h5py</code> here.</p> Solution <pre><code>import h5py\n\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n# load the \"jets\" and \"tracks_loose\" dataset from the h5 file\nwith h5py.File(ttbar_filepath, \"r\") as h5file:\n    jets = h5file[\"jets\"][:]\n    tracks = h5file[\"tracks_loose\"][:]\n\n# print the shape and the field names of the datasets\nprint(jets.shape)\nprint(jets.dtype.names)\nprint(tracks.shape)\nprint(tracks.dtype.names)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-12-plotting-the-p_tp_t-distribution-for-jets-of-different-flavours","title":"Task 1.2: Plotting the p_T distribution for jets of different flavours","text":"<p>As a next step, you will produce a histogram plot that shows the p_T distribution of light-flavour jets, b-jets and b-jets.</p> Hint: How do I create a histogram plot with <code>puma</code>? <p>You can find the examples of histogram plots here and the documentation for histogram plots with <code>puma</code> here.</p> Solution <pre><code>import h5py\nfrom puma import Histogram, HistogramPlot\n\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n\n# load the jets dataset from the h5 file\nwith h5py.File(ttbar_filepath, \"r\") as h5file:\n    jets = h5file[\"jets\"][:]\n\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\n# initialise the plot\npt_plot = HistogramPlot(\n    bins_range=(0, 250_000),\n    xlabel=\"$p_T$ [MeV]\",\n    ylabel=\"Normalised number of jets\",\n)\n\n# add the histograms\npt_plot.add(Histogram(jets[is_light][\"pt_btagJes\"], flavour=\"ujets\"))\npt_plot.add(Histogram(jets[is_c][\"pt_btagJes\"], flavour=\"cjets\"))\npt_plot.add(Histogram(jets[is_b][\"pt_btagJes\"], flavour=\"bjets\"))\n\npt_plot.draw()\npt_plot.savefig(\"tutorial_histogram_pT.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-13-plot-the-bb-jets-probability-output-of-two-different-taggers","title":"Task 1.3: Plot the b-jets probability output of two different taggers","text":"<p>In this task you will plot the b-jets probability of two different taggers - RNNIP and DIPS.</p> <ol> <li>Create the histogram plot (similar to the one from the previous task) and the different     histograms. If you plot this for light-flavour jets, c-jets and b-jets, you should     have 6 histograms.</li> <li>Make sure that you use a different linestyle for the histgrams of you second tagger.</li> <li>Add a ratio panel to the plot</li> <li>Make your plot look pretty. Have a look at the arguments that are supported by     <code>puma.PlotObject</code>.</li> </ol> Hint 1: Histogram and HistogramPlot objects <p>After you defined your HistogramPlot object, you can start adding lines to it. This lines are the Histogram objects you need to define.</p> Hint 2: Linestyle <p>The <code>linestyle</code> can be set when the different <code>Histogram</code> lines are initalised.</p> Hint 3: Ratio Panel <p>The ratio for the ratio panel is calculated in this case between the same flavours. But you need to tell the plot which of the Histogram objects is the reference. Try to look up the <code>reference</code> option in the <code>add()</code> function.</p> Solution <pre><code>tagger_output_plot = HistogramPlot(\n    n_ratio_panels=1,\n    xlabel=\"$b$-jets probability\",\n    ylabel=\"Normalised number of jets\",\n    # optional:\n    # figsize=(6, 4.5),\n    # leg_ncol=2,\n    # atlas_second_tag=\"$t\\\\bar{t}$ R22 sample\",\n    # logy=True,\n)\n\n# add the histograms\ntagger_output_plot.add(\n    Histogram(jets[is_light][\"rnnip_pb\"], ratio_group=\"ujets\", flavour=\"ujets\"),\n    reference=True,\n)\ntagger_output_plot.add(\n    Histogram(jets[is_c][\"rnnip_pb\"], ratio_group=\"cjets\", flavour=\"cjets\"),\n    reference=True,\n)\ntagger_output_plot.add(\n    Histogram(jets[is_b][\"rnnip_pb\"], ratio_group=\"bjets\", flavour=\"bjets\"),\n    reference=True,\n)\n\n# add the histograms\ntagger_output_plot.add(\n    Histogram(\n        jets[is_light][\"dipsLoose20220314u2_pb\"],\n        ratio_group=\"ujets\",\n        flavour=\"ujets\",\n        linestyle=\"--\"\n    )\n)\ntagger_output_plot.add(\n    Histogram(\n        jets[is_c][\"dipsLoose20220314v2_pb\"],\n        ratio_group=\"cjets\",\n        flavour=\"cjets\",\n        linestyle=\"--\"\n    )\n)\ntagger_output_plot.add(\n    Histogram(\n        jets[is_b][\"dipsLoose20220314v2_pb\"],\n        ratio_group=\"bjets\",\n        flavour=\"bjets\",\n        linestyle=\"--\"\n    )\n)\n\ntagger_output_plot.draw()\ntagger_output_plot.savefig(\"tutorial_histogram_tagger_pb_comparison.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-14-plot-a-track-variable-of-your-choice","title":"Task 1.4: Plot a track variable of your choice","text":"<p>In this task you are asked to make a histogram plot of a track variable. This is slightly more tricky, since the array that you load from the h5 file has a different shape compared to the array storing the jet information. In addition to that, many entries might be filled with <code>nan</code> values, which is challenging here and there.</p> <ol> <li>Choose a track variable that you want to plot.</li> <li>Create a histogram plot (maybe again for multiple flavours, but that is up to you).</li> </ol> Hint 1: NaN-Values in binning <p>If you encounter an issue with NaN values in the binning, you need to set the <code>bins_range</code> correctly, because with NaN values it cannot be calculated automatically.</p> Hint 2: Difference in Shape <p>Due to the dimensionality of tracks, you need to get rid of one of the dimensions. Try the <code>.flatten()</code> option of <code>numpy.ndarray</code>'s</p> Solution <pre><code>with h5py.File(ttbar_filepath, \"r\") as h5file:\n    tracks = h5file[\"/tracks_loose\"][:, :]\n    print(tracks.shape)\n\nd0_plot = HistogramPlot(\n    bins_range=(-3, 3),\n    xlabel=\"$d_0$ significance\",\n    ylabel=\"Normalised number of tracks\",\n    figsize=(6, 4.5),\n)\n\nd0_plot.add(\n    Histogram(\n        tracks[\"IP3D_signed_d0_significance\"][is_light, :].flatten(), flavour=\"ujets\"\n    )\n)\nd0_plot.add(\n    Histogram(tracks[\"IP3D_signed_d0_significance\"][is_c, :].flatten(), flavour=\"cjets\")\n)\nd0_plot.add(\n    Histogram(tracks[\"IP3D_signed_d0_significance\"][is_b, :].flatten(), flavour=\"bjets\")\n)\n\nd0_plot.draw()\nd0_plot.savefig(\"tutorial_histogram_track_variable.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-2-roc-plots","title":"Task 2: ROC plots","text":"<p>In this task, you will plot a ROC comparison for the two taggers RNNIP and DIPS.</p>"},{"location":"examples/tutorial-plotting/#task-21-calculate-the-rejections-as-a-function-of-the-bb-jets-efficiency","title":"Task 2.1: Calculate the rejections as a function of the b-jets efficiency","text":"<p>Before you can actually plot the ROC curves, you have to calculate the light-flavour and c-jets rejection for a range of b-jets efficiencies.</p> <ol> <li>Define a function that calculates the b-jets discriminant from the tagger output.</li> <li>Calculate the light-flavour jets rejection as a function of the b-jets efficiency.</li> </ol> Solution <pre><code>import numpy as np\nimport pandas as pd\nimport h5py\n\nfrom puma import Roc, RocPlot\nfrom puma.metrics import calc_rej\n\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n\n# load the jets dataset from the h5 file\n\nwith h5py.File(ttbar_filepath, \"r\") as h5file:\n    jets = pd.DataFrame(h5file[\"jets\"][:])\n\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\n# define a small function to calculate discriminant\ndef disc_fct(arr: np.ndarray, f_c: float = 0.018) -&gt; np.ndarray:\n    \"\"\"Tagger discriminant\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        array with with shape (, 3)\n    f_c : float, optional\n        f_c value in the discriminant (weight for c-jets rejection)\n\n    Returns\n    -------\n    np.ndarray\n        Array with the discriminant values inside.\n    \"\"\"\n    # you can adapt this for your needs\n    return np.log(arr[2] / (f_c * arr[1] + (1 - f_c) * arr[0]))\n\n\n# calculate discriminant\ndiscs_rnnip = np.apply_along_axis(\n    disc_fct, 1, jets[[\"rnnip_pu\", \"rnnip_pc\", \"rnnip_pb\"]].values\n)\ndiscs_dips = np.apply_along_axis(\n    disc_fct,\n    1,\n    jets[\n        [\"dipsLoose20220314v2_pu\", \"dipsLoose20220314v2_pc\", \"dipsLoose20220314v2_pb\"]\n    ].values,\n)\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\nn_jets_light = sum(is_light)\nn_jets_c = sum(is_c)\n\nrnnip_ujets_rej = calc_rej(discs_rnnip[is_b], discs_rnnip[is_light], sig_eff)\ndips_ujets_rej = calc_rej(discs_dips[is_b], discs_dips[is_light], sig_eff)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-22","title":"Task 2.2:","text":"<ol> <li>Plot the light-flavour jets rejection as a function of the b-jets efficiency. Use     <code>n_ratio_panels=1</code> to also get the ratio of the two rejection curves.</li> </ol> Hint 1: How do I initialise a ROC curve plot? <p>Plotting ROC curves with <code>puma</code> is similar to plotting histograms. The main difference is that you are using the <code>puma.RocPlot</code> and <code>puma.Roc</code> classes. Search the [puma docs] for \"roc\" to have a look at an example and the API reference.</p> Hint 2: I initialised the plot and added the ROC curves - is there anything else to do? <p>For ROC curves you also have to define the class which is drawn in the ratio panel. The method you need to use here is <code>RocPlot.set_ratio_class()</code>.</p> Solution <pre><code># here the plotting of the roc starts\nroc_plot = RocPlot(\n    n_ratio_panels=1,\n    ylabel=\"Background rejection\",\n    xlabel=\"$b$-jets efficiency\",\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, $t\\\\bar{t}$ Release 22, \\n$f_c=0.018$\",\n)\nroc_plot.add_roc(\n    Roc(\n        sig_eff,\n        rnnip_ujets_rej,\n        n_test=n_jets_light,\n        rej_class=\"ujets\",\n        signal_class=\"bjets\",\n        label=\"RNNIP\",\n    ),\n    reference=True,\n)\nroc_plot.add_roc(\n    Roc(\n        sig_eff,\n        dips_ujets_rej,\n        n_test=n_jets_light,\n        rej_class=\"ujets\",\n        signal_class=\"bjets\",\n        label=\"DIPS\",\n    ),\n)\nroc_plot.set_ratio_class(1, \"ujets\", label=\"Light-flavour jets ratio\")\nroc_plot.set_leg_rej_labels(\"ujets\", \"Light-flavour jets rejection\")\nroc_plot.draw()\nroc_plot.savefig(\"tutorial_roc.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-23-add-the-cc-rejection-to-your-plot","title":"Task 2.3: Add the c-rejection to your plot","text":"<ol> <li>Repeat the calculation of the rejection for c-jets</li> <li>Add the corresponding ROC curves to the plot. Don't forget to increase <code>n_ratio_panels</code>     of your <code>puma.RocPlot</code>.</li> </ol> Hint 1: How can I modify the legend that states which linestyle corresponds to the different rejection classes <p>You can add labels for the different rejection classes using the <code>RocPlot.set_leg_rej_labels()</code> method.</p> Solution <pre><code>rnnip_cjets_rej = calc_rej(discs_rnnip[is_b], discs_rnnip[is_c], sig_eff)\ndips_cjets_rej = calc_rej(discs_dips[is_b], discs_dips[is_c], sig_eff)\n\n# add this to the code from the previous task (has to be before the RocPlot.draw()\n# method is called)\nroc_plot.add_roc(\n    Roc(\n        sig_eff,\n        rnnip_cjets_rej,\n        n_test=n_jets_c,\n        rej_class=\"cjets\",\n        signal_class=\"bjets\",\n        label=\"RNNIP\",\n    ),\n    reference=True,\n)\nroc_plot.add_roc(\n    Roc(\n        sig_eff,\n        dips_cjets_rej,\n        n_test=n_jets_c,\n        rej_class=\"cjets\",\n        signal_class=\"bjets\",\n        label=\"DIPS\",\n    ),\n)\nroc_plot.set_ratio_class(2, \"cjets\", label=\"$c$-jets ratio\")\nroc_plot.set_leg_rej_labels(\"cjets\", \"$c$-jets rejection\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-3-p_tp_t-vs-efficiency","title":"Task 3: p_T vs. efficiency","text":"<p>In this task, you will plot both the b-jets efficiency and the light-flavour jets rejection for specific bins of p_T.</p>"},{"location":"examples/tutorial-plotting/#task-31-calculate-the-discriminant-values","title":"Task 3.1: Calculate the discriminant values","text":"<p>Just like you did in Task 2.1, calculate the discriminant scores for RNNIP and DIPS. You can reuse the code from task 2.1. If you are putting everything in one python script you can just reuse the values that are already calculated.</p>"},{"location":"examples/tutorial-plotting/#task-32-create-a-p_tp_t-vs-bb-efficiency-plot","title":"Task 3.2: Create a p_T vs. b-efficiency plot","text":"<p>For a fixed inclusive b-efficiency, you plot the b-efficiency for different bins of p_T.</p> Solution <pre><code>import numpy as np\nimport pandas as pd\nimport h5py\n\nfrom puma import VarVsEff, VarVsEffPlot\n\nttbar_filepath = \"/eos/user/u/umamibot/tutorials/ttbar.h5\"\n\n# load the jets dataset from the h5 file\nwith h5py.File(ttbar_filepath, \"r\") as h5file:\n    jets = pd.DataFrame(h5file[\"jets\"][:])\n\n# define a small function to calculate discriminant\ndef disc_fct(arr: np.ndarray, f_c: float = 0.018) -&gt; np.ndarray:\n    \"\"\"Tagger discriminant\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        array with with shape (, 3)\n    f_c : float, optional\n        f_c value in the discriminant (weight for c-jets rejection)\n\n    Returns\n    -------\n    np.ndarray\n        Array with the discriminant values inside.\n    \"\"\"\n    # you can adapt this for your needs\n    return np.log(arr[2] / (f_c * arr[1] + (1 - f_c) * arr[0]))\n\n\n# calculate discriminant\ndiscs_rnnip = np.apply_along_axis(\n    disc_fct, 1, jets[[\"rnnip_pu\", \"rnnip_pc\", \"rnnip_pb\"]].values\n)\ndiscs_dips = np.apply_along_axis(\n    disc_fct,\n    1,\n    jets[\n        [\"dipsLoose20220314v2_pu\", \"dipsLoose20220314v2_pc\", \"dipsLoose20220314v2_pb\"]\n    ].values,\n)\n\n# Getting jet pt in GeV\npt = jets[\"pt\"].values / 1e3\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\n# here the plotting starts\n\n# define the curves\nrnnip_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_rnnip[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_rnnip[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    disc_cut=None,\n    fixed_eff_bin=False,\n    label=\"RNNIP\",\n)\ndips_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_dips[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_dips[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    disc_cut=None,\n    fixed_eff_bin=False,\n    label=\"DIPS\",\n)\n\n\n# You can choose between different modes: \"sig_eff\", \"bkg_eff\", \"sig_rej\", \"bkg_rej\"\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, PFlow jets, \\n$t\\\\bar{t}$ sample, $f_{c}=0.018$\",\n    figsize=(6, 4.5),\n    n_ratio_panels=1,\n)\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\nplot_sig_eff.atlas_second_tag += \"\\nInclusive $\\\\epsilon_b=70%%$\"\n\n# If you want to inverse the discriminant cut you can enable it via\n# plot_sig_eff.set_inverse_cut()\nplot_sig_eff.draw()\n# Drawing a hline indicating inclusive efficiency\nplot_sig_eff.draw_hline(0.7)\nplot_sig_eff.savefig(\"tutorial_pt_b_eff.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-33-create-a-p_tp_t-vs-light-flavour-jets-rejection-plot","title":"Task 3.3: Create a p_T vs. light-flavour jets rejection plot","text":"Solution <pre><code># reuse the VarVsEff objects that were defined for the previous exercise\nplot_bkg_rej = VarVsEffPlot(\n    mode=\"bkg_rej\",\n    ylabel=\"Light-flavour jets rejection\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, PFlow jets \\n$t\\\\bar{t}$ sample, $f_{c}=0.018$\",\n    figsize=(6, 4.5),\n    n_ratio_panels=1,\n)\nplot_sig_eff.atlas_second_tag += \"\\nInclusive $\\\\epsilon_b=70%%$\"\nplot_bkg_rej.add(rnnip_light, reference=True)\nplot_bkg_rej.add(dips_light)\n\nplot_bkg_rej.draw()\nplot_bkg_rej.savefig(\"tutorial_pt_light_rej.png\")\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-4-plotting-inside-of-umami","title":"Task 4: Plotting inside of Umami","text":"<p>Although <code>puma</code> gives you the opportunity to plot all the histograms by yourself in a very easy way, most of the plots you did up till now are also producable via <code>umami</code>. We will start in this tutorial with the plotting of input variables with some specific settings. To do so, you need to fork and clone the <code>umami</code> repository from here.</p>"},{"location":"examples/tutorial-plotting/#task-41-setup-umami","title":"Task 4.1: Setup umami","text":"<p>To use all the functionalities of <code>umami</code>, you need to properly setup and load <code>umami</code>. Try to access the <code>umami</code> singularity image and source the <code>run_setup.sh</code>.</p> Hint: Setup umami <p>You can find the documentation of <code>umami</code> here.</p> Solution: Setup umami <p>After you have forked and downloaded it, you can (and should be able to) switch to the umami folder and start the <code>umami</code> singularity image (the same one you are already using). Now you just need to run the setup for <code>umami</code> via</p> <pre><code>source run_setup.sh\n</code></pre> <p>which should load all needed settings for <code>umami</code>.</p>"},{"location":"examples/tutorial-plotting/#task-42-create-a-new-plotting-config-file","title":"Task 4.2: Create a new Plotting Config File","text":"<p><code>umami</code> uses yaml files as config files for most of it's functions. One of the most basic functionalities is the plotting of variables inside a <code>.h5</code> file which was produced by the training-dataset-dumper. To do so, you need to create a new yaml config file. This config file should contain for now just one dict named <code>Eval_parameters</code> with two entries: <code>nJets</code> and <code>var_dict</code>. <code>nJets</code> is an <code>int</code> for how many jets will be used for plotting and <code>var_dict</code> is a string with the path to the variable config which will be used. For this tutorial, you can use one of the configs provided inside of <code>umami</code>. The path is <code>umami/umami/configs/Umami_Variables_R22.yaml</code>.</p> Hint: Create a new plotting config file <p>A little explanation how python dicts are written in yaml files is given here</p> Solution: Create a new plotting config file <pre><code>Eval_parameters:\n  nJets: 3e4\n  var_dict: &lt;path_palce_holder&gt;/umami/umami/configs/Dips_Variables.yaml\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-43-plot-jet-input-variables","title":"Task 4.3: Plot Jet Input Variables","text":"<p>The most basic to plot are the jet-level variables. To plot those, you need to add a new entry to the dict in the yaml file. The name of the entry is not relevant but this dict entry needs very specific keys. To guide you trough the process, small sub-tasks are given here. To run the plotting of the jet variables, you need to run the following command in the <code>umami/umami/</code> directory</p> <pre><code>plot_input_vars.py -c &lt;path/to/config&gt; --jets\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-431-plot-the-p_tp_t-and-etaeta-distribution","title":"Task 4.3.1: Plot the p_T and |\\eta| distribution","text":"<p>Try to plot the <code>pt_btagJes</code> and the <code>absEta_btagJes</code> distributions for the ttbar and the Z' sample in the same and in two different plots. Plot this for the b-, c- and light jets (all in one plot).</p> Hint: Plot the p_T and |\\eta| distribution <p>The explanation of the different options are given here. The label values of the different flavours can be found here.</p> Solution: Plot the p_T and |\\eta| distribution <pre><code>ttbar_only:\n  variables: \"jets\"\n  folder_to_save: jets_input_vars\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n  binning:\n    pt_btagJes: 100\n    absEta_btagJes: 100\n  flavours:\n    b: 5\n    c: 4\n    u: 0\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n</code></pre> <pre><code>zpext_only:\n  variables: \"jets\"\n  folder_to_save: jets_input_vars\n  Datasets_to_plot:\n    zpext:\n      files: &lt;path_palce_holder&gt;/zpext.h5\n      label: \"zpext\"\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n  binning:\n    pt_btagJes: 100\n    absEta_btagJes: 100\n  flavours:\n    b: 5\n    c: 4\n    u: 0\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n</code></pre> <pre><code>ttbar_zpext:\n  variables: \"jets\"\n  folder_to_save: jets_input_vars\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n    zpext:\n      files: &lt;path_palce_holder&gt;/zpext.h5\n      label: \"zpext\"\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n  binning:\n    pt_btagJes: 100\n    absEta_btagJes: 100\n  flavours:\n    b: 5\n    c: 4\n    u: 0\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-432-adding-new-variables-to-the-variable-config-file","title":"Task 4.3.2: Adding new Variables to the Variable Config File","text":"<p>Try to add the output probabilities of the <code>dipsLoose20220314v2</code> tagger to the <code>var_dict</code> file in a new sublist called <code>DIPS</code>. The probabilites are named using the tagger name and the probability in short form, i.e. <code>dipsLoose20220314v2_pb</code>.</p> Hint: Adding new Variables to the Variable Config File <p>The <code>var_dict</code> file can be found in the umami folder under the path <code>umami/umami/configs/Umami_Variables_R22.yaml</code>. The variable names you need to add are <code>dipsLoose20220314v2_pb</code>, <code>dipsLoose20220314v2_pc</code>, <code>dipsLoose20220314v2_pu</code>. To plot the new variables, you need to also add them to the <code>binning</code> of the already existing config entries.</p> Solution: Adding new Variables to the Variable Config File <pre><code>ttbar_only:\n  variables: \"jets\"\n  folder_to_save: jets_input_vars\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n  binning:\n    pt_btagJes: 100\n    absEta_btagJes: 100\n    dipsLoose20220314v2_pb: 100\n    dipsLoose20220314v2_pc: 100\n    dipsLoose20220314v2_pu: 100\n  flavours:\n    b: 5\n    c: 4\n    u: 0\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n</code></pre> <p>The other two can be adapted similary.</p>"},{"location":"examples/tutorial-plotting/#task-433-adding-specific-lower-and-upper-x-limits","title":"Task 4.3.3: Adding specific lower and upper x-limits","text":"<p>Try to plot the <code>JetFitterSecondaryVertex_nTracks</code> variable from <code>0</code> to <code>17</code> with 17 bins.</p> Hint: Adding specific lower and upper x-limits <p>The entry, like <code>binning</code> and <code>flavours</code>, you are looking for is called <code>special_param_jets</code>. You can look this up here.</p> Solution: Adding specific lower and upper x-limits <pre><code>ttbar_only:\n  variables: \"jets\"\n  folder_to_save: jets_input_vars\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n  binning:\n    pt_btagJes: 100\n    absEta_btagJes: 100\n    dipsLoose20220314v2_pb: 100\n    dipsLoose20220314v2_pc: 100\n    dipsLoose20220314v2_pu: 100\n    JetFitterSecondaryVertex_nTracks: 17\n  flavours:\n    b: 5\n    c: 4\n    u: 0\n  special_param_jets:\n    JetFitterSecondaryVertex_nTracks:\n      lim_left: 0\n      lim_right: 17\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n</code></pre> <p>The other two can be adapted similary.</p>"},{"location":"examples/tutorial-plotting/#task-44-plot-track-input-variables","title":"Task 4.4: Plot Track Input Variables","text":"<p>Due to the different dimensionality of the <code>tracks</code>, the track input variables have their own plotting function. The setup for the plots is pretty similar to the ones of the jets. To guide you through the different possibilities you have when plotting, there are some sub-tasks. To run the plotting of the track variables, you need to run the following command in the <code>umami/umami/</code> directory</p> <pre><code>plot_input_vars.py -c &lt;path/to/config&gt; --tracks\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-441-plot-all-tracks","title":"Task 4.4.1: Plot all Tracks","text":"<p>Try to plot the <code>IP3D_signed_d0_significance</code> and the <code>IP3D_signed_z0_significance</code> of the ttbar and Z' test files (ttbar only, Z' only, both in the same plots). You need to figure out how the <code>tracks</code> are called inside the files to properly load them and plot them.</p> Hint: Plot all Tracks <p>The name of the <code>tracks</code> in the files can be found out by using the <code>h5ls</code> command. For the entry in the config, you can look into the documentation for the options you need to define. This can be done here.</p> Solution: Plot all Tracks <pre><code>ttbar_only:\n  variables: \"tracks\"\n  folder_to_save: ttbar_only\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n      tracks_name: \"tracks_loose\"\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n  binning:\n    IP3D_signed_d0_significance: 100\n    IP3D_signed_z0_significance: 100\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n</code></pre> <pre><code>zpext_only:\n  variables: \"tracks\"\n  folder_to_save: zpext_only\n  Datasets_to_plot:\n    zpext:\n      files: &lt;path_palce_holder&gt;/zpext.h5\n      label: \"zpext\"\n      tracks_name: \"tracks_loose\"\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n  binning:\n    IP3D_signed_d0_significance: 100\n    IP3D_signed_z0_significance: 100\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n</code></pre> <pre><code>ttbar_zpext:\n  variables: \"tracks\"\n  folder_to_save: ttbar_zpext\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n      tracks_name: \"tracks_loose\"\n    zpext:\n      files: &lt;path_palce_holder&gt;/zpext.h5\n      label: \"zpext\"\n      tracks_name: \"tracks_loose\"\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n  binning:\n    IP3D_signed_d0_significance: 100\n    IP3D_signed_z0_significance: 100\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n</code></pre>"},{"location":"examples/tutorial-plotting/#task-442-plot-only-second-leading-tracks-in-ptfrac","title":"Task 4.4.2: Plot only Second-leading Tracks in <code>ptfrac</code>","text":"<p>One specific thing about the tracks is the ordering. To order them properly, you can give the <code>sorting_variable</code> option which tells the function, after which variable the tracks are sorted (in decreasing order, starting with the highest value). Also, you can tell the function which n-leading tracks from each jet should be plotted. Try to plot only the second leading tracks (ordered by <code>ptfrac</code>).</p> Hint: Plot only Second-leading Tracks in <code>ptfrac</code> <p>You can adapt again the plot config of the last sub-task. The options you need here to add can be found here.</p> Solution: Plot only Second-leading Tracks in <code>ptfrac</code> <pre><code>ttbar_only:\n  variables: \"tracks\"\n  folder_to_save: ttbar_only\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n      tracks_name: \"tracks_loose\"\n  plot_settings:\n    logy: True\n    use_atlas_tag: True\n    atlas_first_tag: \"Simulation Internal\"\n    atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n    y_scale: 2\n    figsize: [7, 5]\n    sorting_variable: \"ptfrac\"\n    n_leading: [2]\n  binning:\n    IP3D_signed_d0_significance: 100\n    IP3D_signed_z0_significance: 100\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n</code></pre> <p>The other two can be adapted similary.</p>"},{"location":"examples/tutorial-plotting/#task-45-plot-number-of-tracks-per-flavour","title":"Task 4.5: Plot Number of Tracks per Flavour","text":"<p>Another important factor of the tracks is the track multiplicity for the given jets. This can also be plotted using the umami. To do so, you need to define another entry in your config file. In theory, you can keep the basic structure from the <code>tracks</code> plotting, but you can get rid of the <code>binning</code> part and set the <code>nTracks</code> argument to <code>True</code>. Try to plot the number of tracks for the files (ttbar, Z', both) for the three basic flavours.</p> Hint: Plot Number of Tracks per Flavour <p>All options available (and which are necessary and optional) can be found here.</p> Solution: Plot Number of Tracks per Flavour <pre><code>nTracks_ttbar:\n  variables: \"tracks\"\n  folder_to_save: nTracks_ttbar\n  nTracks: True\n  Datasets_to_plot:\n    ttbar:\n      files: &lt;path_palce_holder&gt;/ttbar.h5\n      label: \"ttbar\"\n      tracks_name: \"tracks_loose\"\n  plot_settings:\n      logy: True\n      use_atlas_tag: True\n      atlas_first_tag: \"Simulation Internal\"\n      atlas_second_tag: \"$\\\\sqrt{s}$ = 13 TeV, $t\\\\bar{t}$ PFlow jets \\n30000 jets\"\n      y_scale: 2\n      figsize: [7, 5]\n  class_labels: [\"bjets\", \"cjets\", \"ujets\"]\n</code></pre> <p>The other two can be adapted similary.</p>"},{"location":"examples/tutorial-plotting/#bonus-tasks","title":"Bonus tasks","text":""},{"location":"examples/tutorial-plotting/#run-over-a-run-3-mc-sample-and-compare-the-pileup-distributions","title":"Run over a Run-3 MC sample and compare the pileup distributions","text":"<p>This task will extend over the simple histogram plotting you already encountered in Task 1. You are asked to compare distributions from two different files: the Run-2 MC for the Z' sample and the Run-3 MC for the Z' sample.</p> <p>For this task, you will:</p> <ol> <li>Download the Z' sample for the Run-3 MC <code>zpext_run3.h5</code> from <code>/eos/user/u/umamibot/tutorials/</code>.</li> <li>Write a plotting script to compare the <code>averageInteractionsPerCrossing</code> between the two samples.</li> </ol> Solution <p>Copy the Run-3 MC file (assuming you work on lxplus):</p> <pre><code>cp /eos/user/u/umamibot/tutorials/zpext_run3.h5 &lt;/path/to/tutorial/data/&gt;\n</code></pre> <p>You should provide a path for the dummy <code>&lt;/path/to/tutorial/data/&gt;</code> in the command above and in the python example below:</p> <pre><code>import numpy as np\nimport h5py\nfrom puma import Histogram, HistogramPlot\n\n# load the \"jets\" datasets from the h5 files\nfilepath_run2 = \"/path/to/tutorial/data/zpext.h5\"\nwith h5py.File(filepath_run2, \"r\") as h5file:\n    jets_run2 = h5file[\"jets\"][:]\n\nfilepath_run3 = \"/path/to/tutorial/data/zpext_run3.h5\"\nwith h5py.File(filepath_run3, \"r\") as h5file:\n    jets_run3 = h5file[\"jets\"][:]\n\nvariable = \"averageInteractionsPerCrossing\"\nrun_2 = Histogram(jets_run2[variable], label=\"Run 2 MC\")\nrun_3 = Histogram(jets_run3[variable], label=\"Run 3 MC\")\n\n# Initialise histogram plot\nplot_histo = HistogramPlot(\n    ylabel=\"Number of events\",\n    xlabel=r\"average interactions per crossing $\\langle\\mu\\rangle$ [a.u.]\",\n    logy=False,\n    bins=60,\n    bins_range=(10, 70),\n    norm=True,\n    atlas_first_tag=\"Simulation Internal\",\n    atlas_second_tag=\"Example for a comparison plot\",\n    figsize=(6, 5),\n    n_ratio_panels=1,\n)\n\n# Add histograms and plot\nplot_histo.add(run_2, reference=True)\nplot_histo.add(run_3)\nplot_histo.draw()\n\nplot_histo.savefig(\"histogram_pileup.png\", transparent=False)\n</code></pre>"},{"location":"examples/tutorial-plotting/#compare-the-flipped-taggers-to-the-regular-flavour-tagging-algorithms","title":"Compare the \"flipped taggers\" to the regular flavour tagging algorithms","text":"<p>This task further extends over the simple histogram plotting you already encountered in Task 1. You are asked to compare distributions from a regular flavour tagging algorithm and a so-called \"flipped tagger\", which is a modified version of the flavour tagging algorithm used for light-jet mistag calibration. For this version, the sign of d0/z0 signed impact parameter is flipped, resulting in a selection of jets with \u201cnegative lifetime\u201d.</p> <p>Consequently, the flipped tagger's b-tagging efficiency is reduced while its light-jet mistag rate is left unchanged.</p> <p>For this task, you will:</p> <ol> <li>Write a plotting script to compare the scores p_b, p_c, and p_u, for the RNNIP tagger to the flipped version. You should produce three plots, one for each score (such as p_b), which show the distributions of the RNNIP tagger and the flipped RNNIP tagger overlaid for the three different jet flavours b-jets, c-jets and light-flavour jets.</li> <li>Next, extend the script to compare also the flavour tagging discriminant based on the flipped tagger and the regular RNNIP tagger. You should produce one plot which compares the distributions of the RNNIP tagger and the flipped RNNIP tagger overlaid for the three different jet flavours b-jets, c-jets and light-flavour jets.</li> </ol> Hint: Names of the RNNIP tagger and the flipped tagger scores and the corresponding b-tagging discriminant <p>The names of the RNNIP tagger scores are</p> <ul> <li><code>rnnip_pu</code></li> <li><code>rnnip_pc</code></li> <li><code>rnnip_pb</code></li> </ul> <p>The names of the flipped version are</p> <ul> <li><code>rnnipflip_pu</code></li> <li><code>rnnipflip_pc</code></li> <li><code>rnnipflip_pb</code></li> </ul> <p>An example how the discriminant can be calculated is provided in one of the puma example scripts.</p> Solution <p>You should provide the path for the dummy <code>&lt;/path/to/tutorial/data/&gt;</code> in the python example below:</p> <pre><code>import numpy as np\nimport h5py\nimport pandas as pd\nfrom puma import Histogram, HistogramPlot\n\n# load the \"jets\" dataset from the h5 file\nfilepath = \"/path/to/tutorial/data/ttbar.h5\"\nwith h5py.File(filepath, \"r\") as h5file:\n    jets = h5file[\"jets\"][:]\n    jets = pd.DataFrame(jets)\n\n\n# defining boolean arrays to select the different flavour classes\nis_light = jets[\"HadronConeExclTruthLabelID\"] == 0\nis_c = jets[\"HadronConeExclTruthLabelID\"] == 4\nis_b = jets[\"HadronConeExclTruthLabelID\"] == 5\n\n\n# Calculate discriminant scores for RNNIP and flipped tagger, and add them to the dataframe\nFRAC_C = 0.07\njets[\"disc_rnnip\"] = np.log(\n    jets[\"rnnip_pb\"] / (FRAC_C * jets[\"rnnip_pc\"] + (1 - FRAC_C) * jets[\"rnnip_pu\"])\n)\njets[\"disc_rnnipflip\"] = np.log(\n    jets[\"rnnipflip_pb\"] / (FRAC_C * jets[\"rnnipflip_pc\"] + (1 - FRAC_C) * jets[\"rnnipflip_pu\"])\n)\n\nvariables = [\n    ('rnnip_pu', 'rnnipflip_pu'),\n    ('rnnip_pc', 'rnnipflip_pc'),\n    ('rnnip_pb', 'rnnipflip_pb'),\n    ('disc_rnnip', 'disc_rnnipflip'),\n]\n\naxis_labels = {\n    'rnnip_pu': 'RNNIP $p_{light}$',\n    'rnnip_pc': 'RNNIP $p_{c}$',\n    'rnnip_pb': 'RNNIP $p_{b}$',\n    'disc_rnnip': 'RNNIP b-tagging discriminant',\n}\n\n\n# plot score and discriminantdistributions\nfor v in variables:\n    rnnip_light = Histogram(jets[is_light][v[0]], flavour=\"ujets\", label=\"RNNIP\")\n    rnnip_c = Histogram(jets[is_c][v[0]], flavour=\"cjets\", label=\"RNNIP\")\n    rnnip_b = Histogram(jets[is_b][v[0]], flavour=\"bjets\", label=\"RNNIP\")\n\n    rnnip_light_flip = Histogram(jets[is_light][v[1]], linestyle=\"dashed\", flavour=\"ujets\", label=\"RNNIP (flip)\")\n    rnnip_c_flip = Histogram(jets[is_c][v[1]], linestyle=\"dashed\", flavour=\"cjets\", label=\"RNNIP (flip)\")\n    rnnip_b_flip = Histogram(jets[is_b][v[1]], linestyle=\"dashed\", flavour=\"bjets\", label=\"RNNIP (flip)\")\n\n    # Initialise histogram plot\n    plot_histo = HistogramPlot(\n        ylabel=\"Number of events\",\n        xlabel=axis_labels[v[0]],\n        logy=True,\n        bins=np.linspace(-10, 10, 40) if v[0] == 'disc_rnnip' else np.linspace(0, 1, 20),\n        norm=False,\n        atlas_first_tag=\"Simulation Internal\",\n        figsize=(6, 5),\n        n_ratio_panels=1,\n    )\n\n    # Add histograms and plot\n    plot_histo.add(rnnip_light, reference=True)\n    plot_histo.add(rnnip_c, reference=True)\n    plot_histo.add(rnnip_b, reference=True)\n    plot_histo.add(rnnip_light_flip)\n    plot_histo.add(rnnip_c_flip)\n    plot_histo.add(rnnip_b_flip)\n    plot_histo.draw()\n\n    plot_histo.savefig(f\"histogram_flip_{v[0]}.png\", transparent=False)\n</code></pre>"},{"location":"examples/var_vs_eff/","title":"Variable vs efficiency plots","text":"<p>In the following a small example how to plot the efficiency vs a specific variable. In this case, we use <code>pt</code> as this variable.</p> <p>Then we can start the actual plotting part</p> <p></p> <p></p> <pre><code>\"\"\"Produce pT vs efficiency plot from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom ftag import get_discriminant\n\nfrom puma import VarVsEff, VarVsEffPlot\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\ndf = get_dummy_2_taggers(add_pt=True)\n\nlogger.info(\"caclulate tagger discriminants\")\ndiscs_rnnip = get_discriminant(df, \"rnnip\", signal=\"bjets\", fc=0.018)\ndiscs_dips = get_discriminant(df, \"dips\", signal=\"bjets\", fc=0.018)\n\n# you can also use a results file directly, you can comment everything above and\n# uncomment below\n# ttbar_file = \"&lt;resultsfile.h5\"\n# df = pd.read_hdf(ttbar_file, key=\"ttbar\")\n\n# discs_rnnip = df[\"disc_rnnip\"]\n# discs_dips = df[\"disc_dips\"]\n# is_light = df[\"labels\"] == 0\n# is_c = df[\"labels\"] == 1\n# is_b = df[\"labels\"] == 2\n\n# Getting jet pt in GeV\npt = df[\"pt\"] / 1e3\n# defining target efficiency\nsig_eff = np.linspace(0.49, 1, 20)\n# defining boolean arrays to select the different flavour classes\nis_light = df[\"HadronConeExclTruthLabelID\"] == 0\nis_c = df[\"HadronConeExclTruthLabelID\"] == 4\nis_b = df[\"HadronConeExclTruthLabelID\"] == 5\n\n# here the plotting starts\n\n# define the curves\nrnnip_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_rnnip[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_rnnip[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"RNNIP\",\n)\ndips_light = VarVsEff(\n    x_var_sig=pt[is_b],\n    disc_sig=discs_dips[is_b],\n    x_var_bkg=pt[is_light],\n    disc_bkg=discs_dips[is_light],\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    working_point=0.7,\n    disc_cut=None,\n    flat_per_bin=False,\n    label=\"DIPS\",\n)\n\n\nlogger.info(\"Plotting bkg rejection for inclusive efficiency as a function of pt.\")\n# You can choose between different modes: \"sig_eff\", \"bkg_eff\", \"sig_rej\", \"bkg_rej\"\nplot_bkg_rej = VarVsEffPlot(\n    mode=\"bkg_rej\",\n    ylabel=\"Light-flavour jets rejection\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\nplot_bkg_rej.add(rnnip_light, reference=True)\nplot_bkg_rej.add(dips_light)\n\nplot_bkg_rej.draw()\nplot_bkg_rej.savefig(\"pt_light_rej.png\")\n\nplot_sig_eff = VarVsEffPlot(\n    mode=\"sig_eff\",\n    ylabel=\"$b$-jets efficiency\",\n    xlabel=r\"$p_{T}$ [GeV]\",\n    logy=False,\n    atlas_second_tag=\"$\\\\sqrt{s}=13$ TeV, dummy jets, \\ndummy sample, $f_{c}=0.018$\",\n    n_ratio_panels=1,\n)\nplot_sig_eff.add(rnnip_light, reference=True)\nplot_sig_eff.add(dips_light)\n\nplot_sig_eff.atlas_second_tag += \"\\nInclusive $\\\\epsilon_b=70\\\\%$\"\n\n# If you want to inverse the discriminant cut you can enable it via\n# plot_sig_eff.set_inverse_cut()\nplot_sig_eff.draw()\n# Drawing a hline indicating inclusive efficiency\nplot_sig_eff.draw_hline(0.7)\nplot_sig_eff.savefig(\"pt_b_eff.png\", transparent=False)\n</code></pre>"},{"location":"hlapi/","title":"High level API","text":"<p>To set up the inputs for the plots, have a look here.</p> <p>The following examples use the dummy data which is described here</p> <p>All the previous examples show how to use the plotting of individual plots often requiring a fair amount of code to produce ROC curves etc.</p> <p>This high level API facilitates several steps and is designed to quickly plot b- and c-jet performance plots.</p>"},{"location":"hlapi/#initialising-the-taggers","title":"Initialising the taggers","text":"<p>The <code>Results</code> object is initialised with the signal class, by default this is <code>bjets</code> but can be changed to <code>cjets</code> to produce the c-tagging plots, or <code>Hbb</code>/<code>Hcc</code> for Xbb tagging.</p> <pre><code>\"\"\"Produce roc curves from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nfrom puma.hlplots import Results, Tagger\nfrom puma.utils import get_dummy_2_taggers, logger\n\n# The line below generates dummy data which is similar to a NN output\nfile = get_dummy_2_taggers(add_pt=True, return_file=True)\n\n# define jet selections\ncuts = [(\"n_truth_promptLepton\", \"==\", 0)]\n\n# define the taggers\ndips = Tagger(\n    name=\"dips\",\n    label=\"dummy DIPS ($f_{c}=0.005$)\",\n    fxs={\"fc\": 0.005, \"fb\": 0.04},\n    colour=\"#AA3377\",\n)\nrnnip = Tagger(\n    name=\"rnnip\",\n    label=\"dummy RNNIP ($f_{c}=0.07$)\",\n    fxs={\"fc\": 0.07, \"fb\": 0.04},\n    colour=\"#4477AA\",\n    reference=True,\n)\n\n# create the Results object\n# for c-tagging use signal=\"cjets\"\n# for Xbb/cc-tagging use signal=\"hbb\"/\"hcc\"\nresults = Results(signal=\"bjets\", sample=\"dummy\")\n\n# load taggers from the file object\nlogger.info(\"Loading taggers.\")\nresults.load_taggers_from_file(\n    [dips, rnnip],\n    file.filename,\n    cuts=cuts,\n    num_jets=len(file[\"jets\"]),\n)\n\nresults.atlas_second_tag = (\n    \"$\\\\sqrt{s}=13$ TeV, dummy jets \\n$t\\\\bar{t}$, $20$ GeV $&lt; p_{T} &lt;250$ GeV\"\n)\n</code></pre>"},{"location":"hlapi/#probability-distributions","title":"Probability distributions","text":"<p>You can get the output probability distributions just run <pre><code># tagger probability distributions\nresults.plot_probs(logy=True, bins=40)\n</code></pre></p>"},{"location":"hlapi/#discriminant-plots","title":"Discriminant plots","text":"<p>To plot the discriminant, you can now simply call one function and everything else is handled automatically, here for the b-jet discriminant <pre><code># tagger discriminant distributions\nlogger.info(\"Plotting tagger discriminant plots.\")\nresults.plot_discs(logy=False, wp_vlines=[60, 85])\nresults.plot_discs(logy=True, wp_vlines=[60, 85], suffix=\"log\")\n</code></pre></p>"},{"location":"hlapi/#roc-plots","title":"ROC plots","text":"<p>In the same manner you can plot ROC curves, here for the b-tagging performance <pre><code># ROC curves\nlogger.info(\"Plotting ROC curves.\")\nresults.plot_rocs()\n</code></pre></p>"},{"location":"hlapi/#performance-vs-a-variable","title":"Performance vs a variable","text":"<p>In this case we plot the performance as a function of the jet pT with the same syntax as above for an inclusive working point of 70% <pre><code># eff/rej vs. variable plots\nlogger.info(\"Plotting efficiency/rejection vs pT curves.\")\nresults.atlas_second_tag = \"$\\\\sqrt{s}=13$ TeV, dummy jets \\n$t\\\\bar{t}$\"\n\n# or alternatively also pass the argument `working_point` to the plot_var_perf function.\n# specifying the `disc_cut` per tagger is also possible.\nresults.plot_var_perf(\n    working_point=0.7,\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    flat_per_bin=False,\n)\n</code></pre></p> <p>and similar for a fixed b-efficiency per bin. <pre><code>results.atlas_second_tag = \"$\\\\sqrt{s}=13$ TeV, dummy jets \\n$t\\\\bar{t}$\"\nresults.plot_var_perf(\n    bins=[20, 30, 40, 60, 85, 110, 140, 175, 250],\n    flat_per_bin=True,\n    working_point=0.7,\n    h_line=0.7,\n    disc_cut=None,\n)\n</code></pre></p> <p>Similar to above you can also do these plots for c-tagging by changing the <code>signal_class</code> to <code>cjets</code>.</p>"},{"location":"hlapi/#fraction-scans","title":"Fraction scans","text":"<p>Plot the two background efficiencies as a function of the f_c or f_b value.</p> <pre><code># fraction scan plots\nlogger.info(\"Plotting fraction scans.\")\nresults.atlas_second_tag = \"$\\\\sqrt{s}=13$ TeV, dummy jets \\n$t\\\\bar{t}$\\n70% WP\"\nresults.plot_fraction_scans(efficiency=0.7, rej=False)\n</code></pre>"},{"location":"hlapi/high_level_aux_api/","title":"High level API for aux task plots","text":"<p>To set up the inputs for the plots, have a look here. In general, the input structure is the same for aux task plots, but a separate container with track-level aux task outputs is required to be present in the files (by default \"tracks\"). For now, vertexing and track origin prediction aux tasks are supported.</p> <p>The following examples use the dummy data which is described here</p> <p>The high level API for aux tasks matches the general high level API in terms of structure. It can be used to produce vertexing performance plots.</p>"},{"location":"hlapi/high_level_aux_api/#initialising-the-taggers","title":"Initialising the taggers","text":"<p>Compared to the <code>Results</code> object, an <code>AuxResults</code> object is initialized without definition of a signal class (rather this is passed to the plotting functions directly). Otherwise initialization proceeds in the same fashion. Taggers can be added to these objects in an analogous way to <code>Results</code>, except that each tagger should be initialized with a list of available aux tasks (by default \"vertexing\" and \"track_origin\"). Relevant information for these aux tasks will then be read in from the provided file, assuming the information is available and the specific aux task is properly supported within puma. The <code>AuxResults</code> object also allows for track variables (such as pT, eta, etc.) to be loaded in for each tagger. These are listed out via the <code>aux_perf_vars</code> attribute and allow for calculation of vertex masses. If (track) <code>deta</code> is specified in <code>aux_perf_vars</code> and (jet) <code>eta</code> in <code>perf_vars</code>, (track) <code>eta</code> is automatically calculated and added to <code>aux_perf_vars</code>.</p> <pre><code>\"\"\"Produce aux task plots from tagger output and labels.\"\"\"\n\nfrom __future__ import annotations\n\nfrom puma.hlplots import AuxResults, Tagger\nfrom puma.utils import get_dummy_tagger_aux, logger\n\n# The line below generates dummy data which is similar to a NN output\nfname, file = get_dummy_tagger_aux()\n\n# define jet selections\ncuts = [(\"n_truth_promptLepton\", \"==\", 0)]\n\n# define the tagger\nGN2 = Tagger(\n    name=\"GN2\",\n    label=\"dummy GN2\",\n    colour=\"#4477AA\",\n    reference=True,\n)\n\n# create the AuxResults object\naux_results = AuxResults(\n    sample=\"dummy\",\n    aux_perf_vars=[\"pt\", \"eta\", \"dphi\"],\n)\n\n# load tagger from the file object\nlogger.info(\"Loading taggers.\")\naux_results.load_taggers_from_file(\n    [GN2],\n    fname,\n    cuts=cuts,\n    num_jets=len(file[\"jets\"]),\n)\n</code></pre>"},{"location":"hlapi/high_level_aux_api/#vertexing-performance","title":"Vertexing performance","text":"<p>Vertexing performance plots can be produced for a specified jet flavour as shown in <pre><code># vertexing performance for b-jets\nlogger.info(\"Plotting vertexing performance.\")\naux_results.plot_var_vtx_perf(vtx_flavours=[\"bjets\"], no_vtx_flavours=[\"ujets\"])\n</code></pre> Here <code>vtx_flavours</code> defines a list of flavours for which secondary vertices are expected (e.g. b-jets) and <code>no_vertex_flavours</code> defines a list where secondary vertices are not expected (e.g. l-jets). Different plots are produced in each case (see below). In general, this plotting function handles all considerations for vertexing performance. This includes processing truth vertex indices by removing vertices containing tracks not from HF and reco vertices by removing the vertex most consistent with the reconstructed PV (if a tagger has the capability to identify tracks from a PV via track origin classification). See here for more information about truth track origin and vertex definitions. If inclusive vertexing is enabled, all HF vertices are merged into a single truth vertex. For reconstructed vertices in a tagger with track origin classification, all vertices with at least one HF track are merged and all others are removed. If track origin classification is not available, but inclusive vertexing is enabled, then all vertices are merged. After this cleaning procedure, a 1:1 greedy matching procedure between truth and reconstructed vertices is performed, with which all the relevant performance metrics for plots are calculated. In total, 4 plots are produced for each jet flavour with expected SVs and 1 is produced for each flavour with no expected SVs (all plotted against specific performance variable):</p> <ul> <li>Vertexing efficiency: defined as number of vertices matched divided by number of true vertices (expected SVs)</li> <li>Vertexing purity: defined as number of vertices matched divided by number of reconstructed vertices (expected SVs)</li> <li>Track-vertex association efficiency: defined as number of tracks in matched vertex common between truth and reco vertices divided by number of tracks in true vertex (expected SVs)</li> <li>Track-vertex association purity: defined as number of tracks in matched vertex common between truth and reco vertices divided by number of tracks in reco vertex (expected SVs)</li> <li>Vertexing fake rate: fraction of jets where at least one SV is found (no expected SVs)</li> </ul> <p>Note that by default the vertex matching algorithm enforces purity criteria requiring track association efficiency &gt; 0.65 and purity &gt; 0.5</p>"},{"location":"hlapi/high_level_aux_api/#vertex-mass-reconstruction","title":"Vertex mass reconstruction","text":"<p>Secondary vertex mass histograms can be produced for a specified jet flavour as shown in <pre><code># vertex mass reconstruction performance for b-jets\nlogger.info(\"Plotting secondary vertex masses.\")\naux_results.plot_vertex_mass(vtx_flavours=[\"bjets\"])\n</code></pre> Vertex masses are calculated using a pion hypothesis for all tracks, both for truth and reconstructed vertices with the given values for pT, eta and phi. These plots can be produced for inclusive or exclusive vertexing as defined in the vertexing section. For inclusive vertexing, difference plots are also produced, which show differences in the reco vs. truth mass estimates on a vertex by vertex basis.</p>"},{"location":"hlapi/high_level_aux_api/#track-origin-performances","title":"Track Origin Performances","text":"<p>The Track Origin auxiliary task is a multiclass classification task, in which each track is associated with its most probable belonging origin, chosen between:</p> <ul> <li>Pileup;</li> <li>Fake;</li> <li>Primary;</li> <li>FromB;</li> <li>FromBC;</li> <li>FromC;</li> <li>FromTau;</li> <li>OtherSecondary;</li> </ul> <p>A good metric to evaluate the performances of the classifier is the Confusion Matrix, which can be plotted using the method <code>plot_track_origin_confmat</code>.</p> <p>The normalization of the tagger's confusion matrix can be chosen among the ones allowed by the <code>confusion_matrix</code> possible normalizations, by specifying the argument <code>normalize</code> in the <code>plot_track_origin_confmat</code> function. By default, the matrix's rows are normalized.</p>"},{"location":"hlapi/n_track_origin/","title":"Number of Tracks per Track Origin","text":"<p>To understand the amount of tracks per jet as a function of p_\\mathrm{T}, PUMA provides a high-level function named <code>n_tracks_per_origin</code>. This function can load an <code>.h5</code> from the Training-Dataset-Dumper and extract the number of tracks per jet (and per track origin) as a function of p_\\mathrm{T}.</p> <p>An example of the usage of this function can be found here:</p> <pre><code>\"\"\"Plotting example of the n_tracks_per_origin function.\"\"\"\n\nfrom __future__ import annotations\n\nfrom urllib.request import urlretrieve\n\nimport numpy as np\nfrom ftag import Flavours\n\nfrom puma.hlplots import n_tracks_per_origin\n\n# Download test h5 sample\nurlretrieve(\n    \"https://umami-ci-provider.web.cern.ch/\" \"plot_input_vars/plot_input_vars_r22_check.h5\",\n    \"testfile.h5\",\n)\n\n# Define the grouping of the track origins\ntrack_origin_dict = {\n    \"All\": range(8),\n    # \"Fragmentation\": [1, 2],\n    \"HF decay\": [3, 4, 5],\n    # \"From $\\\\tau$\": [6],\n    \"Others\": [0, 1, 2, 6, 7],\n}\n\n# Define a list with all flavours that should be plotted\nflavour_list = [\n    Flavours.bjets,\n    Flavours.cjets,\n    Flavours.ujets,\n]\n\n# Define the dict with all samples that are to be plotted\nfiles_dict = {\n    \"ttbar\": {\n        \"filepath\": \"testfile.h5\",\n        \"n_jets\": 10000,\n        \"tracks_name\": \"tracks_loose\",\n        \"pt_bins\": np.linspace(20_000, 250_000, 20),\n        \"process_label\": \"$t\\\\bar{t}$\",\n        \"jet_pt_variable\": \"pt_btagJes\",\n        \"track_truth_variable\": \"truthOriginLabel\",\n        \"flavour_label_variable\": \"HadronConeExclTruthLabelID\",\n    },\n}\n\n# Plotting all samples for one flavour per plot\nn_tracks_per_origin(\n    flavour_list=flavour_list,\n    files=files_dict,\n    track_origin_dict=track_origin_dict,\n    plot_type=\"all_samples_one_flavour\",\n    plot_path=\"./\",\n    plot_format=\"pdf\",\n    plot_name=\"Test_plots\",\n)\n\n# Plotting all flavour for one sample per plot\nn_tracks_per_origin(\n    flavour_list=flavour_list,\n    files=files_dict,\n    track_origin_dict=track_origin_dict,\n    plot_type=\"one_sample_all_flavour\",\n    plot_path=\"./\",\n    plot_format=\"pdf\",\n    plot_name=\"Test_plots\",\n)\n</code></pre>"},{"location":"hlapi/yuma/","title":"YUMA (Yaml Plotting)","text":"<p>YUMA (Yaml for pUMA) removes boilerplate required for making simple flavour tagging plots, instead moving everything required into yaml config files, and acting as a wrapper around the high-level plotting functionality included in puma. To make plots, two config files are required, a <code>taggers.yaml</code> and <code>plot_cfg.yaml</code>. Examples of these can be found in <code>puma/examples</code>.</p> <p>To create plots, after modifying the two files, run</p> <pre><code>yuma --config examples/plot_cfg.yaml \n</code></pre> <p>Additional arguments can be included:</p> <ul> <li><code>--plots [roc, scan, disc, prob, peff]</code> Select one or more type of plots to produce.</li> <li><code>--signals [bjets, cjets]</code> what signals to plot</li> <li><code>--num_jets [n]</code> number of jets to load per tagger (before cuts are applied)</li> </ul>"},{"location":"hlapi/yuma/#taggersyaml","title":"taggers.yaml","text":"<p>The <code>taggers.yaml</code> file contains required information for taggers we wish to load. Under 'taggers' are the defined taggers. Each should be assigned a tag, which is used as the 'name' of the tagger and its settings. Within in tagger, arguments that can be parsed to the Tagger high-level class can be used. If you wish to plot the same tagger multiple times, for example with different <code>fc</code> values, you can also include a name:</p> <pre><code>GN2_fc0:\n    name: GN2v01\n    [args]\nGN2_fc0p1:\n    name: GN2v01\n    [args]\n</code></pre> <p>In this case, both models will be the GN2v01 from whichever sample is specified. You should add <code>GN2_fc0</code> and <code>GN2_fc0p1</code> as the taggers in the plot config to plot both.</p>"},{"location":"hlapi/yuma/#plot_cfgyaml","title":"plot_cfg.yaml","text":"<p>This file contains info on what taggers to load, what plots to make, and where to save them.</p>"},{"location":"hlapi/yuma/#global-options","title":"Global options","text":"<ul> <li><code>plot_dir:</code> - The base directory to write plots to. The pltos will be saved to a directory of the form <code>plot_dir/plt_cfg</code>.</li> <li><code>timestamp: False</code> - If True, will create a new directory each time the script is run, with a timestamp included in the name. If False, then will save to the default directory, and overwrite any files.</li> <li><code>results_config:</code> - Arguments to parse to the 'Results' class.</li> <li><code>taggers_config:</code> - Path to the <code>taggers.yaml</code> file.</li> <li><code>taggers:</code> - List of tagger names that we wish to plot.</li> <li><code>reference_tagger:</code> - Tagger name that shall be the 'reference' tagger. Any ratios by default are with respect to this tagger.</li> <li><code>sample:</code> - Information on the sample plotted, including the name, any cuts for the sample, and a sample string to include in the plot info.</li> <li><code>all_flavours</code> - A list which defines all the flavours available. If defined, then background flavours are defined as <code>all_flavours - signal</code>, if not defined, then default backgrounds are assigned (e.g, cjets and lightjets if signal=bjets) -<code>label_var</code> - What variable define the class labels. By default <code>HadronConeExclTruthLabelID</code></li> </ul>"},{"location":"hlapi/yuma/#plots","title":"Plots","text":"<p>Each plot type should come under its own section. The allowed plots are:</p> <ul> <li>roc_plots</li> <li>fracscan_plots</li> <li>disc_plots</li> <li>prob_plots</li> <li>eff_vs_var_plots</li> </ul> <p>Within each section, a list of plots should be included. Each plot requires a 'signal'. Additional options that work for all plot types are:</p> <ul> <li>suffix: Allows a custom suffix for the plot name.</li> <li>include_taggers: Only include the specified taggers for this plot</li> <li>exclude_taggers: Plot all taggers, except those in 'exclude_taggers'</li> <li>plot_kwargs: arguments parsed to the base plot object, such as figsize.</li> </ul> <p>Other specific plot types have additional arguments that can be included:</p>"},{"location":"hlapi/yuma/#roc-plots","title":"ROC plots","text":"<ul> <li>x_range: The x-range of the signal efficiency</li> </ul>"},{"location":"hlapi/yuma/#fraction-scan-plots","title":"Fraction Scan plots","text":"<ul> <li>frac_flav: The x in 'f_x', for example 'c' for standard f_c plots</li> <li>efficiency: The signal efficiency to plot at</li> <li>backgrounds: List of two backgrounds to plot the scan over.</li> </ul>"},{"location":"hlapi/yuma/#efficiency-vs-var-plots","title":"Efficiency Vs Var plots","text":"<ul> <li>peff_var: The variable to bin on the x-axis, default is pt bins: The bin edges for the x-axis, default for pT depends on if sample is ttbar/zprime</li> </ul>"}]}